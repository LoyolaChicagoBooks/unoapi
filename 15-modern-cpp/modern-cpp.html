<!DOCTYPE html>

<html :class="{'dark': darkMode === 'dark' || (darkMode === 'system' &amp;&amp; window.matchMedia('(prefers-color-scheme: dark)').matches)}" class="scroll-smooth" lang="en" x-data="{ darkMode: localStorage.getItem('darkMode') || localStorage.setItem('darkMode', 'system'), activeSection: '' }" x-init="$watch('darkMode', val =&gt; localStorage.setItem('darkMode', val))">
<head>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta charset="utf-8"/>
<meta content="white" media="(prefers-color-scheme: light)" name="theme-color"/>
<meta content="black" metia="(prefers-color-scheme: dark)" name="theme-color"/>
<meta content="Docutils 0.18.1: http://docutils.sourceforge.net/" name="generator"/>
<title>Modern C++ as a Better C (and C++) | UnoAPI Book v0.3.2</title>
<meta content="Modern C++ as a Better C (and C++) | UnoAPI Book v0.3.2" property="og:title"/>
<meta content="Modern C++ as a Better C (and C++) | UnoAPI Book v0.3.2" name="twitter:title"/>
<link href="../_static/pygments.css" rel="stylesheet"/>
<link href="../_static/theme.47abdafeea10b5ccf58b.css" rel="stylesheet"/>
<link href="../search.html" rel="search" title="Search"/>
<link href="../genindex.html" rel="index" title="Index"/>
<link href="../18-dpcpp/dpcpp.html" rel="next" title="Data-Parallel C++ with oneAPI/SYCL"/>
<link href="../10-software-engineering/software-engineering.html" rel="prev" title="Introduction to Software Engineering"/>
<script>
    <!-- Prevent Flash of wrong theme -->
      const userPreference = localStorage.getItem('darkMode');
      let mode;
      if (userPreference === 'dark' || window.matchMedia('(prefers-color-scheme: dark)').matches) {
        mode = 'dark';
        document.documentElement.classList.add('dark');
      } else {
        mode = 'light';
      }
      if (!userPreference) {localStorage.setItem('darkMode', mode)}
    </script>
<script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
<script src="../_static/doctools.js"></script>
<script src="../_static/sphinx_highlight.js"></script>
<script defer="" src="../_static/theme.4ea23184acb23c5e9294.js"></script>
</head>
<body :class="{ 'overflow-hidden': showSidebar }" class="min-h-screen font-sans antialiased bg-background text-foreground" x-data="{ showSidebar: false }">
<div @click.self="showSidebar = false" class="fixed inset-0 z-50 overflow-hidden bg-background/80 backdrop-blur-sm" x-cloak="" x-show="showSidebar"></div><div class="relative flex flex-col min-h-screen" id="page"><a class="absolute top-0 left-0 z-[100] block bg-background p-4 text-xl transition -translate-x-full opacity-0 focus:translate-x-0 focus:opacity-100" href="#content">
      Skip to content
    </a>
<header class="sticky top-0 z-40 w-full border-b shadow-sm border-border supports-backdrop-blur:bg-background/60 bg-background/95 backdrop-blur"><div class="container flex items-center h-14">
<div class="hidden mr-4 md:flex">
<a class="flex items-center mr-6" href="../index.html"><span class="hidden font-bold sm:inline-block text-clip whitespace-nowrap">UnoAPI Book v0.3.2</span>
</a></div><button @click="showSidebar = true" class="inline-flex items-center justify-center h-10 px-0 py-2 mr-2 text-base font-medium transition-colors rounded-md hover:text-accent-foreground hover:bg-transparent md:hidden" type="button">
<svg aria-hidden="true" fill="currentColor" height="24" viewbox="0 96 960 960" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M152.587 825.087q-19.152 0-32.326-13.174t-13.174-32.326q0-19.152 13.174-32.326t32.326-13.174h440q19.152 0 32.326 13.174t13.174 32.326q0 19.152-13.174 32.326t-32.326 13.174h-440Zm0-203.587q-19.152 0-32.326-13.174T107.087 576q0-19.152 13.174-32.326t32.326-13.174h320q19.152 0 32.326 13.174T518.087 576q0 19.152-13.174 32.326T472.587 621.5h-320Zm0-203.587q-19.152 0-32.326-13.174t-13.174-32.326q0-19.152 13.174-32.326t32.326-13.174h440q19.152 0 32.326 13.174t13.174 32.326q0 19.152-13.174 32.326t-32.326 13.174h-440ZM708.913 576l112.174 112.174q12.674 12.674 12.674 31.826t-12.674 31.826Q808.413 764.5 789.261 764.5t-31.826-12.674l-144-144Q600 594.391 600 576t13.435-31.826l144-144q12.674-12.674 31.826-12.674t31.826 12.674q12.674 12.674 12.674 31.826t-12.674 31.826L708.913 576Z"></path>
</svg>
<span class="sr-only">Toggle navigation menu</span>
</button>
<div class="flex items-center justify-between flex-1 space-x-2 sm:space-x-4 md:justify-end">
<div class="flex-1 w-full md:w-auto md:flex-none">
<form @keydown.k.window.meta="$refs.search.focus()" action="../search.html" class="relative flex items-center group" id="searchbox" method="get">
<input aria-label="Search the docs" class="inline-flex items-center font-medium transition-colors bg-transparent focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 ring-offset-background border border-input hover:bg-accent focus:bg-accent hover:text-accent-foreground focus:text-accent-foreground hover:placeholder-accent-foreground py-2 px-4 relative h-9 w-full justify-start rounded-[0.5rem] text-sm text-muted-foreground sm:pr-12 md:w-40 lg:w-64" id="search-input" name="q" placeholder="Search ..." type="search" x-ref="search"/>
<kbd class="pointer-events-none absolute right-1.5 top-2 hidden h-5 select-none text-muted-foreground items-center gap-1 rounded border border-border bg-muted px-1.5 font-mono text-[10px] font-medium opacity-100 sm:flex group-hover:bg-accent group-hover:text-accent-foreground">
<span class="text-xs">⌘</span>
      K
    </kbd>
</form>
</div>
<nav class="flex items-center space-x-1">
<button @click="darkMode = darkMode === 'light' ? 'dark' : 'light'" class="relative inline-flex items-center justify-center px-0 text-sm font-medium transition-colors rounded-md hover:bg-accent hover:text-accent-foreground h-9 w-9" type="button">
<svg class="absolute transition-all scale-100 rotate-0 dark:-rotate-90 dark:scale-0" fill="currentColor" height="24" viewbox="0 96 960 960" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M480 685q45.456 0 77.228-31.772Q589 621.456 589 576q0-45.456-31.772-77.228Q525.456 467 480 467q-45.456 0-77.228 31.772Q371 530.544 371 576q0 45.456 31.772 77.228Q434.544 685 480 685Zm0 91q-83 0-141.5-58.5T280 576q0-83 58.5-141.5T480 376q83 0 141.5 58.5T680 576q0 83-58.5 141.5T480 776ZM80 621.5q-19.152 0-32.326-13.174T34.5 576q0-19.152 13.174-32.326T80 530.5h80q19.152 0 32.326 13.174T205.5 576q0 19.152-13.174 32.326T160 621.5H80Zm720 0q-19.152 0-32.326-13.174T754.5 576q0-19.152 13.174-32.326T800 530.5h80q19.152 0 32.326 13.174T925.5 576q0 19.152-13.174 32.326T880 621.5h-80Zm-320-320q-19.152 0-32.326-13.174T434.5 256v-80q0-19.152 13.174-32.326T480 130.5q19.152 0 32.326 13.174T525.5 176v80q0 19.152-13.174 32.326T480 301.5Zm0 720q-19.152 0-32.326-13.17Q434.5 995.152 434.5 976v-80q0-19.152 13.174-32.326T480 850.5q19.152 0 32.326 13.174T525.5 896v80q0 19.152-13.174 32.33-13.174 13.17-32.326 13.17ZM222.174 382.065l-43-42Q165.5 327.391 166 308.239t13.174-33.065q13.435-13.674 32.587-13.674t32.065 13.674l42.239 43q12.674 13.435 12.555 31.706-.12 18.272-12.555 31.946-12.674 13.674-31.445 13.413-18.772-.261-32.446-13.174Zm494 494.761-42.239-43q-12.674-13.435-12.674-32.087t12.674-31.565Q686.609 756.5 705.38 757q18.772.5 32.446 13.174l43 41.761Q794.5 824.609 794 843.761t-13.174 33.065Q767.391 890.5 748.239 890.5t-32.065-13.674Zm-42-494.761Q660.5 369.391 661 350.62q.5-18.772 13.174-32.446l41.761-43Q728.609 261.5 747.761 262t33.065 13.174q13.674 13.435 13.674 32.587t-13.674 32.065l-43 42.239q-13.435 12.674-31.706 12.555-18.272-.12-31.946-12.555Zm-495 494.761Q165.5 863.391 165.5 844.239t13.674-32.065l43-42.239q13.435-12.674 32.087-12.674t31.565 12.674Q299.5 782.609 299 801.38q-.5 18.772-13.174 32.446l-41.761 43Q231.391 890.5 212.239 890t-33.065-13.174ZM480 576Z"></path>
</svg>
<svg class="absolute transition-all scale-0 rotate-90 dark:rotate-0 dark:scale-100" fill="currentColor" height="24" viewbox="0 96 960 960" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M480 936q-151 0-255.5-104.5T120 576q0-138 90-239.5T440 218q25-3 39 18t-1 44q-17 26-25.5 55t-8.5 61q0 90 63 153t153 63q31 0 61.5-9t54.5-25q21-14 43-1.5t19 39.5q-14 138-117.5 229T480 936Zm0-80q88 0 158-48.5T740 681q-20 5-40 8t-40 3q-123 0-209.5-86.5T364 396q0-20 3-40t8-40q-78 32-126.5 102T200 576q0 116 82 198t198 82Zm-10-270Z"></path>
</svg>
</button>
</nav>
</div>
</div>
</header>
<div class="flex-1"><div class="container flex-1 items-start md:grid md:grid-cols-[220px_minmax(0,1fr)] md:gap-6 lg:grid-cols-[240px_minmax(0,1fr)] lg:gap-10"><aside :aria-hidden="!showSidebar" :class="{ 'translate-x-0': showSidebar }" class="fixed inset-y-0 left-0 md:top-14 z-50 md:z-30 bg-background md:bg-transparent transition-all duration-100 -translate-x-full md:translate-x-0 ml-0 p-6 md:p-0 md:-ml-2 md:h-[calc(100vh-3.5rem)] w-5/6 md:w-full shrink-0 overflow-y-auto border-r border-border md:sticky" id="left-sidebar">
<a class="!justify-start text-sm md:!hidden bg-background" href="../index.html"><span class="font-bold text-clip whitespace-nowrap">UnoAPI Book v0.3.2</span>
</a>
<div class="relative overflow-hidden md:overflow-auto my-4 md:my-0 h-[calc(100vh-8rem)] md:h-auto">
<div class="overflow-y-auto h-full w-full relative pr-6"><nav class="table w-full min-w-full my-6 lg:my-8">
<p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../00-preliminaries/preliminaries.html">About the Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05-parallel/parallel.html">Introduction to Parallel Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10-software-engineering/software-engineering.html">Introduction to Software Engineering</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Modern C++ as a Better C (and C++)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18-dpcpp/dpcpp.html">Data-Parallel C++ with oneAPI/SYCL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../30-performance/performance.html">Performance Essentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../80-running/running.html">Compiling and Running oneAPI programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../99-sandbox/issues.html">Issues</a></li>
</ul>
</nav>
</div>
</div>
<button @click="showSidebar = false" class="absolute md:hidden right-4 top-4 rounded-sm opacity-70 transition-opacity hover:opacity-100" type="button">
<svg class="h-4 w-4" fill="currentColor" height="24" stroke="none" viewbox="0 96 960 960" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M480 632 284 828q-11 11-28 11t-28-11q-11-11-11-28t11-28l196-196-196-196q-11-11-11-28t11-28q11-11 28-11t28 11l196 196 196-196q11-11 28-11t28 11q11 11 11 28t-11 28L536 576l196 196q11 11 11 28t-11 28q-11 11-28 11t-28-11L480 632Z"></path>
</svg>
</button>
</aside>
<main class="relative py-6 lg:gap-10 lg:py-8 xl:grid xl:grid-cols-[1fr_300px]">
<div class="w-full min-w-0 mx-auto">
<nav aria-label="breadcrumbs" class="flex items-center mb-4 space-x-1 text-sm text-muted-foreground">
<a class="overflow-hidden text-ellipsis whitespace-nowrap hover:text-foreground" href="../index.html">
<span class="hidden md:inline">UnoAPI Book v0.3.2</span>
<svg aria-label="Home" class="md:hidden" fill="currentColor" height="18" stroke="none" viewbox="0 96 960 960" width="18" xmlns="http://www.w3.org/2000/svg">
<path d="M240 856h120V616h240v240h120V496L480 316 240 496v360Zm-80 80V456l320-240 320 240v480H520V696h-80v240H160Zm320-350Z"></path>
</svg>
</a>
<div class="mr-1">/</div><span aria-current="page" class="font-medium text-foreground overflow-hidden text-ellipsis whitespace-nowrap">Modern C++ as a Better C (and C++)</span>
</nav>
<div id="content" role="main">
<section id="modern-c-as-a-better-c-and-c">
<h1>Modern C++ as a Better C (and C++)<a class="headerlink" href="#modern-c-as-a-better-c-and-c" title="Permalink to this heading">¶</a></h1>
<p>If you want to learn SYCL and oneAPI <em>properly</em>, you will need to come up to speed with Modern C++.  In our experience, we know many people–including ourselves–who say they “know” C++.  C++ has undergone numerous changes since it was introduced in the 1980s and 1990s.  While the original syntax remains intact, if you have not kept up with the changes since then (notably, C++ 11), you should take steps to refresh your knowlege of the language, since many of its recent features make it virtually <em>unrecognizable</em> from its earlier incarnations.</p>
<p>We are particularly impressed with how C++ has incorporated features from modern object-functional languages, some of which we will cover here.  Please let us know if you think other features are worthy of inclusion. As this section is still in draft status, we realize our list may not be exhaustive.</p>
<p>In the remaining discussion, we focus our energy on on language features that are likely to appear in oneAPI/SYCL code examples in our tutorial.</p>
<section id="overview-of-modern-c">
<h2>Overview of Modern C++<a class="headerlink" href="#overview-of-modern-c" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#overview-of-modern-c'">¶</a></h2>
<p>If you already know some Object-Oriented Programming (OOP) concepts and want to learn modern C++, here are some topics that are worthy of exploration:</p>
<p><strong>Standard Library</strong>: The C++ Standard Library provides a wide range of pre-built classes and functions that can be used to perform common tasks. You should learn about the different components of the Standard Library, such as containers, algorithms, and iterators, and how to use them effectively. We avoid using C-style pointer-based data structures in favor of STL classes. We also avoid external C++ data structures whenever the STL classes are most appropriate (and they often are).</p>
<p><strong>Templates</strong>: Templates allow you to write generic code that works with any data type. This can save you a lot of time and effort by reducing code duplication. You should learn how to write function templates and class templates. Class templates are already well employed in STL. We often make use of function templates in our examples.</p>
<p><strong>Smart Pointers</strong>: Smart pointers are a modern way of managing memory in C++. They automatically manage memory allocation and deallocation, making it less prone to memory leaks and errors. You should learn about the different types of smart pointers, including <cite>unique_ptr</cite>, <cite>shared_ptr</cite>, and <cite>weak_ptr</cite>.</p>
<p><strong>Lambda expressions</strong>: Lambda expressions provide a concise way to define anonymous functions, which are functions that have no name. You should learn how to write lambda expressions and how to use them with the Standard Library algorithms. Lambda functions are indispensable when it comes to learning oneAPI and SYCL programming.</p>
<p><strong>Move semantics</strong>: Move semantics is a new feature introduced in C++11 that allows you to transfer the resources of an object to another object. This can lead to more efficient code by avoiding unnecessary copying of objects. You should learn about r-value references, move constructors, and move assignment operators. Move smeantics should be used whenever large (and deep) data structures are involved.</p>
<p><strong>Threading</strong>: Threading allows you to run multiple tasks concurrently. You should learn about the different threading constructs provided by the Standard Library, such as threads, mutexes, and condition variables. Keep in mind, of course, that oneAPI/SYCL are an <em>alternative</em> to threading and also allow for code ot be written without assuming a particular threading model.</p>
<p><strong>Modern C++ features</strong>: C++ has been evolving rapidly in recent years, and new features are being added all the time. You should learn about modern C++ features such as <cite>auto</cite>, <cite>constexpr</cite>, <cite>consteval</cite>, and <cite>module</cite>, which can help you write more efficient and maintainable code. We greatly value software engineering, so all of these modern features will help to write <em>clean code</em>, especially when used judiciously.</p>
<p><strong>Exception handling</strong>: Exception handling allows you to handle runtime errors in a structured way. You should learn about the try-catch blocks and how to throw and catch exceptions. (That said, we try to avoid them in our tutorial in favor of the systems tradition of using error codes whenever possible.)</p>
<p><strong>Ranges</strong>: Ranges in C++ are a new library feature introduced in C++20 that provide a unified and composable way to work with sequences of values, including arrays, containers, and generators. Ranges allow you to express operations on sequences as composable, functional transformations, and can greatly simplify and improve the readability of code that works with sequences.</p>
<p>These topics will allow you to become proficient in modern C++ programming and write efficient, maintainable, and scalable code.</p>
</section>
<section id="language-features">
<h2>Language Features<a class="headerlink" href="#language-features" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#language-features'">¶</a></h2>
<section id="the-modern-c-class">
<h3>The Modern C++ Class<a class="headerlink" href="#the-modern-c-class" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#the-modern-c-class'">¶</a></h3>
<p>Even if you programmed with C++ in the past, you need to understand that C++ has changed a great deal since its debut in the late-1980s and early 1990s.</p>
<p>Here’s an example implementation of the familiar Point class with <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">z</span></code> parameters in modern C++ with support for move semantics:</p>
<p>You can assume that this code can be placed in a C++ header file (e.g. Point.h) as a header-only solution:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef POINT_H</span>
<span class="cp">#define POINT_H</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;utility&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Point</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">x_</span><span class="p">{</span><span class="n">x</span><span class="p">},</span><span class="w"> </span><span class="n">y_</span><span class="p">{</span><span class="n">y</span><span class="p">},</span><span class="w"> </span><span class="n">z_</span><span class="p">{</span><span class="n">z</span><span class="p">}</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="c1">// Copy constructor</span>
<span class="w">    </span><span class="n">Point</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">x_</span><span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">x_</span><span class="p">},</span><span class="w"> </span><span class="n">y_</span><span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">y_</span><span class="p">},</span><span class="w"> </span><span class="n">z_</span><span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">z_</span><span class="p">}</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="c1">// Move constructor</span>
<span class="w">    </span><span class="n">Point</span><span class="p">(</span><span class="n">Point</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">x_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">x_</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)},</span>
<span class="w">          </span><span class="n">y_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">y_</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)},</span>
<span class="w">          </span><span class="n">z_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">z_</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)}</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="c1">// Copy assignment operator</span>
<span class="w">    </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">x_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">x_</span><span class="p">;</span>
<span class="w">        </span><span class="n">y_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">y_</span><span class="p">;</span>
<span class="w">        </span><span class="n">z_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">z_</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Move assignment operator</span>
<span class="w">    </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Point</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">x_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">x_</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">        </span><span class="n">y_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">y_</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">        </span><span class="n">z_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">z_</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Accessors</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">y_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">z</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">z_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x_</span><span class="p">,</span><span class="w"> </span><span class="n">y_</span><span class="p">,</span><span class="w"> </span><span class="n">z_</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="c1">// POINT_H</span>
<span class="w"> </span>
</pre></div>
</div>
<p>In this implementation, the <code class="docutils literal notranslate"><span class="pre">Point</span></code> class has three private data members <code class="docutils literal notranslate"><span class="pre">x_</span></code>, <code class="docutils literal notranslate"><span class="pre">y_</span></code>, and <code class="docutils literal notranslate"><span class="pre">z_</span></code>, representing the coordinates of the point. The class also provides a default constructor and a constructor that takes the <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">z</span></code> values as parameters.</p>
<p>The class also demonstrates the concept of <em>move semantics</em> by providing a constructor and move assignment operators. The move constructor takes an r-value reference to another <code class="docutils literal notranslate"><span class="pre">Point</span></code> object, exchanges its data members with the current object using <code class="docutils literal notranslate"><span class="pre">std::exchange</span></code>, and sets the exchanged data members to zero. The move assignment operator works similarly to the move constructor, but it returns a reference to the current object.</p>
<p>Finally, the class provides accessors for the <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">z</span></code> values, which return the corresponding private data members.</p>
<p>Let’s take a look at how to <em>use</em> this class:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">"point.h"</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Create a point object with x=1.0, y=2.0, z=3.0</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="n">p1</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Copy the point object</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Move the point object</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Output the values of the point objects</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"p1: ("</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">z</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">")"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"p2: ("</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">z</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">")"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"p3: ("</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p3</span><span class="p">.</span><span class="n">z</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">")"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Update the values of the point objects</span>
<span class="w">    </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">6.0</span><span class="p">);</span>
<span class="w">    </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Output the updated values of the point objects</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"p1: ("</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">z</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">")"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"p2: ("</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">z</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">")"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"p3: ("</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p3</span><span class="p">.</span><span class="n">z</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">")"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="move-semantics">
<h3>Move Semantics<a class="headerlink" href="#move-semantics" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#move-semantics'">¶</a></h3>
<p>So it is natural to wonder: What does <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> actually do?</p>
<p><code class="docutils literal notranslate"><span class="pre">std::move()</span></code> is a C++ Standard Library function defined in the <code class="docutils literal notranslate"><span class="pre">&lt;utility&gt;</span></code> header file. It is used to cast an l-value reference to an r-value reference, which enables move semantics.</p>
<p>When an object is moved (using move semantics), its resources (such as dynamically allocated memory) are transferred to the new object instead of being copied. This can lead to more efficient code by avoiding unnecessary copying of objects.</p>
<p>Here’s an example of how to use <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> to enable move semantics:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;utility&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">MyClass</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Default constructor"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="n">data_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">~</span><span class="n">MyClass</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Destructor"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">data_</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Move constructor</span>
<span class="w">    </span><span class="n">MyClass</span><span class="p">(</span><span class="n">MyClass</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Move constructor"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="n">data_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">data_</span><span class="p">;</span>
<span class="w">        </span><span class="n">other</span><span class="p">.</span><span class="n">data_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Move assignment operator</span>
<span class="w">    </span><span class="n">MyClass</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MyClass</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Move assignment operator"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">data_</span><span class="p">;</span>
<span class="w">        </span><span class="n">data_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">data_</span><span class="p">;</span>
<span class="w">        </span><span class="n">other</span><span class="p">.</span><span class="n">data_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">data_</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">MyClass</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="n">MyClass</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">));</span><span class="w"> </span><span class="c1">// move a to b</span>
<span class="w">    </span><span class="n">MyClass</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="c1">// move b to c</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, we define a class <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> that has a default constructor, a destructor, and move semantics enabled through the move constructor and move assignment operator.</p>
<p>We then create an object a of <code class="docutils literal notranslate"><span class="pre">MyClass</span></code>. We move <code class="docutils literal notranslate"><span class="pre">a</span></code> to create a new object <code class="docutils literal notranslate"><span class="pre">b</span></code> using <code class="docutils literal notranslate"><span class="pre">std::move(a)</span></code>. We then move <code class="docutils literal notranslate"><span class="pre">b</span></code> to create a new object <code class="docutils literal notranslate"><span class="pre">c</span></code> using <code class="docutils literal notranslate"><span class="pre">std::move(b)</span></code>.</p>
<p>In the move constructor and move assignment operator, we use <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> to cast the l-value reference to other to an r-value reference, enabling move semantics. This allows us to transfer the resources of the original object to the new object, instead of copying them.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">std::move</span></code> does not actually move anything by itself; it simply enables move semantics by casting an l-value reference to an r-value reference. It is up to the move constructor or move assignment operator to actually perform the move operation.</p>
</section>
<section id="lambda-expressions">
<h3>Lambda Expressions<a class="headerlink" href="#lambda-expressions" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#lambda-expressions'">¶</a></h3>
<p>Lambda expressions in C++ allow you to define anonymous functions directly within your code.
Readers familiar with lambda expressions from other functional or object/functional languages should note that C++ lambda functions differ, fundamentally, in how they manage <em>closures</em> and, in particular, how and whether variables from the enclosing scope can be accessed and or modified.</p>
<section id="basic-lambda-with-no-parameters">
<h4>Basic Lambda with No Parameters<a class="headerlink" href="#basic-lambda-with-no-parameters" title="Permalink to this heading">¶</a></h4>
<p>In the following example, <code class="docutils literal notranslate"><span class="pre">sayHello</span></code> is a lambda function with no parameters, and when we call it, it will print “Hello from lambda!”.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">sayHello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Hello from lambda!"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">sayHello</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="lambda-with-parameters">
<h4>Lambda with Parameters<a class="headerlink" href="#lambda-with-parameters" title="Permalink to this heading">¶</a></h4>
<p>In the following example, the <code class="docutils literal notranslate"><span class="pre">add</span></code> lambda takes two integer parameters and returns their sum.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">divide</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// handle division by zero</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"8.0 / 2.0 = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">divide</span><span class="p">(</span><span class="mf">8.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="lambda-with-explicit-return-type">
<h4>Lambda with Explicit Return Type<a class="headerlink" href="#lambda-with-explicit-return-type" title="Permalink to this heading">¶</a></h4>
<p>And in the following, The <code class="docutils literal notranslate"><span class="pre">divide</span></code> lambda has an explicit return type of <code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">divide</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// handle division by zero</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"8.0 / 2.0 = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">divide</span><span class="p">(</span><span class="mf">8.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="lambda-with-closures">
<h4>Lambda with Closures<a class="headerlink" href="#lambda-with-closures" title="Permalink to this heading">¶</a></h4>
<p>Closures allow lambdas to capture variables from their enclosing scope.</p>
<p>The following shows how to capture variables by value:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Sum = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sum</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// 15</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are captured by value. That is, they can be read but not modified.</p>
<p>The following, however, shows apture by reference:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">incrementA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">a</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">a</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">incrementA</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"a = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// 6</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">a</span></code> is captured by reference in the <code class="docutils literal notranslate"><span class="pre">incrementA</span></code> lambda.</p>
<p>Having to capture variables, individually, is not practical when there are more than a couple of variables needed by the lambda function. All variables can be captured by value:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Sum"</span><span class="w">  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sum</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And the following shows how to Capture everything by reference (use with caution):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">incrementBoth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">a</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">b</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">incrementBoth</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Increment Both "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"a = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" b = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">b</span><span class="w">  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>These are foundational examples of lambdas and closures in C++. Lambdas can be even more versatile with features like mutable lambdas and complex capture rules.</p>
</section>
</section>
<section id="naming-conventions">
<h3>Naming Conventions<a class="headerlink" href="#naming-conventions" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#naming-conventions'">¶</a></h3>
<p>What naming convention uses _ at the end of member variable names?</p>
<p>The convention of using an underscore at the end of member variable names is often used to distinguish them from other identifiers in the code, such as local variables or function parameters. This convention is often referred to as “trailing underscore” or “trailing underscore convention”.</p>
<p>It is important to note that this naming convention is not part of the C++ language standard, and different coding styles or organizations may have different conventions for naming member variables. Some coding standards discourage the use of trailing underscores altogether, as they can make the code less readable and harder to maintain.</p>
<p>In general, it is a good practice to follow the naming conventions established by the coding style used in your project or organization, or to adopt a widely recognized naming convention such as the Google C++ Style Guide or the LLVM Coding Standards.</p>
<p>A possibility for avoiding underscore is to reorganize the member variables with a struct. The struct is a lightweight to create a value object in C++.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef _POINT_H_</span>
<span class="cp">#define _POINT_H_</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;utility&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Point</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">coords</span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">}</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="c1">// Copy constructor</span>
<span class="w">    </span><span class="n">Point</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">coords</span><span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">coords</span><span class="p">}</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="c1">// Move constructor</span>
<span class="w">    </span><span class="n">Point</span><span class="p">(</span><span class="n">Point</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">coords</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">coords</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="c1">// Copy assignment operator</span>
<span class="w">    </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">coords</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Move assignment operator</span>
<span class="w">    </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Point</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">coords</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Accessors</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">coords</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">coords</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">z</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">coords</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Scale the Point by a double factor</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">scale</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">factor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">coords</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">factor</span><span class="p">;</span>
<span class="w">        </span><span class="n">coords</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">factor</span><span class="p">;</span>
<span class="w">        </span><span class="n">coords</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">factor</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Translate the Point by another Point</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">coords</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">coords</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">        </span><span class="n">coords</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">coords</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="w">        </span><span class="n">coords</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">coords</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Coords</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">Coords</span><span class="w"> </span><span class="n">coords</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif</span>
</pre></div>
</div>
</section>
<section id="adding-this-to-a-cmake-folder">
<h3>Adding this to a CMake folder<a class="headerlink" href="#adding-this-to-a-cmake-folder" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#adding-this-to-a-cmake-folder'">¶</a></h3>
<p>Here is how put the <cite>Point</cite> class (header) in a Cmake project with a folder named point_example and a cmake rule to build it:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span><span class="w"> </span><span class="s">3.5</span><span class="p">)</span>

<span class="nb">project</span><span class="p">(</span><span class="s">point_example</span><span class="p">)</span>

<span class="c"># Create a library for the Point class</span>
<span class="nb">add_library</span><span class="p">(</span><span class="s">Point</span><span class="w"> </span><span class="s">INTERFACE</span><span class="p">)</span>
<span class="nb">target_include_directories</span><span class="p">(</span><span class="s">Point</span><span class="w"> </span><span class="s">INTERFACE</span><span class="w"> </span><span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="p">)</span>

<span class="c"># Create an executable for the point_example</span>
<span class="nb">add_executable</span><span class="p">(</span><span class="s">point_example</span><span class="w"> </span><span class="s">main.cpp</span><span class="p">)</span>

<span class="c"># Link the Point library to the point_example executable</span>
<span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">point_example</span><span class="w"> </span><span class="s">PRIVATE</span><span class="w"> </span><span class="s">Point</span><span class="p">)</span>
</pre></div>
</div>
<p>In this CMakeLists.txt file, we first set the minimum required version of CMake to 3.5, which is the version that introduced the <cite>target_include_directories</cite> command.</p>
<p>We then create a library for the <cite>Point</cite> class using the <cite>add_library</cite> command with the <cite>INTERFACE</cite> option. The <cite>INTERFACE</cite> option specifies that the library does not have an implementation file, and its headers should be made available to other targets that depend on it. We use the <cite>target_include_directories</cite> command to add the current source directory to the include paths of the <cite>Point</cite> library.</p>
<p>We then create an executable for the point_example using the add_executable command with the source file <cite>main.cpp</cite>. We use the <cite>target_link_libraries</cite> command to link the <cite>Point</cite> library to the <cite>point_example</cite> executable.</p>
<p>To use this <cite>CMakeLists.txt</cite> file, you would create a folder named <cite>point_example</cite> in your project directory, and place the <cite>Point.h</cite> header file and the <cite>main.cpp</cite> source file in that folder.</p>
</section>
<section id="automatic-variables">
<h3>Automatic variables<a class="headerlink" href="#automatic-variables" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#automatic-variables'">¶</a></h3>
<p>The auto keyword was introduced in C++11 as part of the language’s support for type inference.
auto is used to declare a variable whose type is automatically inferred from its initializer (the right hand side of the assignment).
auto can simplify the syntax of variable declarations and make code more concise and readable.
auto is especially useful when working with complex or nested types that may be difficult to express explicitly in code.
In our book, SYCL/oneAPI code is greatly simplified by not having to write the actual data type over and over again.
Code that uses auto is more resilient to changes, since the type of a variable can be changed without needing to update the code that uses it, subject to the compiler checking it, of course.
auto is a useful feature that can simplify code, improve readability, and reduce the likelihood of type errors.</p>
<p>The following shows how auto can be used to initialize some variables of primitive types, e.g. int, double, float, bool, and char.
We also demonstrate how to initialize more complex structures such as an STL generic type (class).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;list&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;map&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;set&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fmt/core.h&gt;</span>

<span class="c1">// This allows us to simulate fmt::join() until fmt &gt;9.1 works with ipcx</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Container</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">format_container</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Container</span><span class="o">&amp;</span><span class="w"> </span><span class="n">container</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">memory_buffer</span><span class="w"> </span><span class="n">buffer</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">size</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">format_to</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="s">"{{"</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fmt</span><span class="o">::</span><span class="n">format_to</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="n">container</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">last</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">fmt</span><span class="o">::</span><span class="n">format_to</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="s">", "</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">format_to</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="s">"}}"</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">fmt</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">d1</span><span class="p">{</span><span class="mf">1.23</span><span class="p">},</span><span class="w"> </span><span class="n">d2</span><span class="p">{</span><span class="mf">4.56</span><span class="p">};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">f1</span><span class="p">{</span><span class="mf">0.123f</span><span class="p">},</span><span class="w"> </span><span class="n">f2</span><span class="p">{</span><span class="mf">6.789f</span><span class="p">};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">b1</span><span class="p">{</span><span class="nb">true</span><span class="p">},</span><span class="w"> </span><span class="n">b2</span><span class="p">{</span><span class="nb">false</span><span class="p">};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">c1</span><span class="p">{</span><span class="sc">'c'</span><span class="p">},</span><span class="w"> </span><span class="n">c2</span><span class="p">{</span><span class="sc">'d'</span><span class="p">};</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">v1</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">}};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">l1</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{</span><span class="n">d1</span><span class="p">,</span><span class="w"> </span><span class="n">d2</span><span class="p">,</span><span class="w"> </span><span class="n">d1</span><span class="p">,</span><span class="w"> </span><span class="n">d2</span><span class="p">,</span><span class="w"> </span><span class="n">d1</span><span class="p">}};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">m1</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">{{</span><span class="n">f1</span><span class="p">,</span><span class="w"> </span><span class="n">b1</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="n">f2</span><span class="p">,</span><span class="w"> </span><span class="n">b2</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="n">f1</span><span class="p">,</span><span class="w"> </span><span class="n">b2</span><span class="p">}}};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">s1</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">{</span><span class="n">c1</span><span class="p">,</span><span class="w"> </span><span class="n">c2</span><span class="p">,</span><span class="w"> </span><span class="n">c1</span><span class="p">,</span><span class="w"> </span><span class="n">c2</span><span class="p">}};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">str1</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span><span class="s">"Hello, world!"</span><span class="p">}};</span>

<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"i = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"d1 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">d1</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"d2 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">d2</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"f1 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">f1</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"f2 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">f2</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"b1 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">b1</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"b2 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">b2</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"c1 = '{}'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">c1</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"c2 = '{}'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">c2</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"v1 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">format_container</span><span class="p">(</span><span class="n">v1</span><span class="p">));</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"l1 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">format_container</span><span class="p">(</span><span class="n">l1</span><span class="p">));</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"m1 = {{{}, {}}}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">m1</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">m1</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"s1 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">format_container</span><span class="p">(</span><span class="n">s1</span><span class="p">));</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"str1 = </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">str1</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="constants-and-constant-expressions">
<h3>Constants and Constant Expressions<a class="headerlink" href="#constants-and-constant-expressions" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#constants-and-constant-expressions'">¶</a></h3>
<p>In this example, we define a pythagorean function using constexpr and lambda expressions.
The function takes two arguments a and b representing the lengths of the two sides of a right-angled triangle, and calculates the length of the hypotenuse using the Pythagorean theorem.</p>
<p>We then define two const variables a and b, which have values of 3.0 and 4.0 respectively. Since a and b are const, we cannot change their values once they have been initialized.</p>
<p>Finally, we initialize a constexpr variable c with the value of pythagorean(a, b). Since a, b, and pythagorean are all const or constexpr, we can evaluate pythagorean(a, b) at compile-time and use it to initialize c.</p>
<p>Using lambda functions is another way to achieve compile-time computations and can simplify the structure for certain operations.</p>
<p>Below is an implementation that uses a lambda function to compute the square root at compile time:</p>
<p>The program then prints the length of the hypotenuse to the console using std::cout.</p>
<p>Overall, this example demonstrates how you can use const and constexpr together to define constants and perform compile-time evaluations of functions, even for more complex calculations such as the Pythagorean theorem.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cmath&gt;</span>

<span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">pythagorean</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pythagorean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"The hypotenuse is "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="initializer-expressions">
<h3>initializer expressions<a class="headerlink" href="#initializer-expressions" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#initializer-expressions'">¶</a></h3>
<p>Initializer expressions are a modern C++ feature that is powerful when combined with <cite>auto</cite>.
You’ll probably find yourself making greater use of them, even when initializing the simplest of variables.
We rely on these extensively in our C++ examples throughout this book.</p>
<p>In this version of the code, we use initializer expressions for each variable declaration.
The syntax for an initializer expression is {} or = {}, and it can be used to initialize a variable with an explicit value.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;list&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;map&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;set&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fmt/core.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">d1</span><span class="p">{</span><span class="mf">1.23</span><span class="p">},</span><span class="w"> </span><span class="n">d2</span><span class="p">{</span><span class="mf">4.56</span><span class="p">};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">f1</span><span class="p">{</span><span class="mf">0.123f</span><span class="p">},</span><span class="w"> </span><span class="n">f2</span><span class="p">{</span><span class="mf">6.789f</span><span class="p">};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">b1</span><span class="p">{</span><span class="nb">true</span><span class="p">},</span><span class="w"> </span><span class="n">b2</span><span class="p">{</span><span class="nb">false</span><span class="p">};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">c1</span><span class="p">{</span><span class="sc">'c'</span><span class="p">},</span><span class="w"> </span><span class="n">c2</span><span class="p">{</span><span class="sc">'d'</span><span class="p">};</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">v1</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">}};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">l1</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{</span><span class="n">d1</span><span class="p">,</span><span class="w"> </span><span class="n">d2</span><span class="p">,</span><span class="w"> </span><span class="n">d1</span><span class="p">,</span><span class="w"> </span><span class="n">d2</span><span class="p">,</span><span class="w"> </span><span class="n">d1</span><span class="p">}};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">m1</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">{{</span><span class="n">f1</span><span class="p">,</span><span class="w"> </span><span class="n">b1</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="n">f2</span><span class="p">,</span><span class="w"> </span><span class="n">b2</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="n">f1</span><span class="p">,</span><span class="w"> </span><span class="n">b2</span><span class="p">}}};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">s1</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">{</span><span class="n">c1</span><span class="p">,</span><span class="w"> </span><span class="n">c2</span><span class="p">,</span><span class="w"> </span><span class="n">c1</span><span class="p">,</span><span class="w"> </span><span class="n">c2</span><span class="p">}};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">str1</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span><span class="s">"Hello, world!"</span><span class="p">}};</span>

<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"i = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"d1 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">d1</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"d2 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">d2</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"f1 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">f1</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"f2 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">f2</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"b1 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">b1</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"b2 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">b2</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"c1 = '{}'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">c1</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"c2 = '{}'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">c2</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"v1 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span><span class="o">::</span><span class="n">join</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="s">", "</span><span class="p">));</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"l1 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span><span class="o">::</span><span class="n">join</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="w"> </span><span class="s">", "</span><span class="p">));</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"m1 = {{{}, {}}}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">m1</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">m1</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"s1 = {{{}}}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span><span class="o">::</span><span class="n">join</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="s">", "</span><span class="p">));</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"str1 = </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">str1</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Using initializer expressions can make the code more concise and improve readability, since each variable is initialized with an explicit value. Additionally, initializer expressions can help prevent bugs caused by uninitialized variables, since each variable is guaranteed to have a value at the point of initialization.</p>
<p>Overall, using initializer expressions is a good practice in C++ programming, and can help make code more concise, readable, and robust.</p>
</section>
<section id="format-and-fmt">
<h3>Format and fmt<a class="headerlink" href="#format-and-fmt" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#format-and-fmt'">¶</a></h3>
<p>C++ 20 draft support for formatted strings (useful feature found in many modern languages, including Python).</p>
<p>Add this to your CMakeFile</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">FetchContent_Declare</span><span class="p">(</span>
<span class="w">        </span><span class="s">fmt</span>
<span class="w">        </span><span class="s">GIT_REPOSITORY</span><span class="w"> </span><span class="s">https://github.com/fmtlib/fmt.git</span>
<span class="w">        </span><span class="s">GIT_TAG</span><span class="w">        </span><span class="s">8.1.1</span>
<span class="p">)</span>
<span class="nb">FetchContent_MakeAvailable</span><span class="p">(</span><span class="s">fmt</span><span class="p">)</span>
</pre></div>
</div>
<p>Simple usage</p>
</section>
<section id="command-line-argument-handling">
<h3>Command-line Argument Handling<a class="headerlink" href="#command-line-argument-handling" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#command-line-argument-handling'">¶</a></h3>
<p>It is virtually impossible to do any sort of scaling experiments in parallel computing withou making your applications <em>parametric</em>. The Unix tradition is built around the command line as a user interface.
To this end, thinking about how to make a command-line interface without the drudgery of writing your own command line parser from scratch is essential to making command-line applications and interfaces.</p>
<p>The following shows how to use the well-established CLI11 framework.
An flag-style argument is created for each data type with a default value that will be set, if not present on the command line.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">"CLI/CLI.hpp"</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">"fmt/format.h"</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">CLI</span><span class="o">::</span><span class="n">App</span><span class="w"> </span><span class="n">app</span><span class="p">{</span><span class="s">"Command-line interface example"</span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Add arguments for each built-in data type</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">"-i,--int"</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="s">"Integer argument"</span><span class="p">);</span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.14</span><span class="p">;</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">"-d,--double"</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="s">"Double argument"</span><span class="p">);</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.71</span><span class="p">;</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">"-f,--float"</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">"Float argument"</span><span class="p">);</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_flag</span><span class="p">(</span><span class="s">"-b,--bool"</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="s">"Boolean argument"</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Hello, world!"</span><span class="p">;</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">"-s,--string"</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="s">"String argument"</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Parse the command-line arguments</span>
<span class="w">    </span><span class="n">CLI11_PARSE</span><span class="p">(</span><span class="n">app</span><span class="p">,</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Print the parsed arguments</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"Parsed arguments:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"  int: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"  double: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"  float: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"  bool: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"  string: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, we create a CLI::App object to represent our command-line interface. We then add an argument for each built-in data type using the CLI::App::add_option() and CLI::App::add_flag() functions. Each argument has a default value that is appropriate for that type.</p>
<p>We then parse the command-line arguments using the CLI11_PARSE macro, which takes the CLI::App object, the argc and argv arguments from the main() function, and parses the arguments.</p>
<p>Finally, we print the parsed arguments using the fmt::print() function from the fmt library. The fmt::print() function takes a format string and any number of arguments, and prints the formatted string to the console. In this example, we use the {} format specifier to insert the values of the parsed arguments into the format string.</p>
<p>Overall, this example demonstrates how you can create a command-line interface with arguments that support each of the built-in data types using the CLI11 package and the fmt library, and how you can print the parsed arguments using the fmt library’s fmt::print() function.</p>
<p>To use the above code, you’ll need to add the following to your CMakeLists.txt file:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span><span class="w"> </span><span class="s">3.16</span><span class="p">)</span>

<span class="nb">project</span><span class="p">(</span><span class="s">CommandLineInterfaceExample</span><span class="p">)</span>

<span class="nb">include</span><span class="p">(</span><span class="s">FetchContent</span><span class="p">)</span>

<span class="c"># Download and configure the CLI11 library</span>
<span class="nb">FetchContent_Declare</span><span class="p">(</span>
<span class="w">    </span><span class="s">cli11</span>
<span class="w">    </span><span class="s">GIT_REPOSITORY</span><span class="w"> </span><span class="s">https://github.com/CLIUtils/CLI11.git</span>
<span class="w">    </span><span class="s">GIT_TAG</span><span class="w"> </span><span class="s">v1.9.1</span>
<span class="p">)</span>
<span class="nb">FetchContent_MakeAvailable</span><span class="p">(</span><span class="s">cli11</span><span class="p">)</span>

<span class="c"># Download and configure the fmt library</span>
<span class="nb">FetchContent_Declare</span><span class="p">(</span>
<span class="w">    </span><span class="s">fmt</span>
<span class="w">    </span><span class="s">GIT_REPOSITORY</span><span class="w"> </span><span class="s">https://github.com/fmtlib/fmt.git</span>
<span class="w">    </span><span class="s">GIT_TAG</span><span class="w"> </span><span class="s">8.1.0</span>
<span class="p">)</span>
<span class="nb">FetchContent_MakeAvailable</span><span class="p">(</span><span class="s">fmt</span><span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span><span class="s">CommandLineInterfaceExample</span><span class="w"> </span><span class="s">main.cpp</span><span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">CommandLineInterfaceExample</span><span class="w"> </span><span class="s">PRIVATE</span><span class="w"> </span><span class="s">CLI11::CLI11</span><span class="w"> </span><span class="s">fmt::fmt</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="better-generics-for-mathematical-functions">
<h3>Better Generics for Mathematical Functions<a class="headerlink" href="#better-generics-for-mathematical-functions" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#better-generics-for-mathematical-functions'">¶</a></h3>
<p>In the following  example, we define a minimum function that takes two generic input parameters <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> of type <code class="docutils literal notranslate"><span class="pre">T</span></code>. We use <code class="docutils literal notranslate"><span class="pre">std::enable_if</span></code> with the condition <code class="docutils literal notranslate"><span class="pre">std::is_arithmetic&lt;T&gt;::value</span></code> to enable the function only for arithmetic types (i.e., integer and floating point types).</p>
<p>The second template parameter is a default value for a pointer type that is enabled only when the first condition is met. The default value is set to <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> to allow the function to have a return type, even when <code class="docutils literal notranslate"><span class="pre">std::enable_if</span></code> disables the function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is known as a “substitution failure is not an error” technique.</p>
</div>
<p>Inside the function, we use the ternary operator to return the smaller of the two input parameters <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<p>This minimum function can be used with any integer or floating point type, including int, double, float, long, long long, etc.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;type_traits&gt;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">*</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">minimum</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="logging">
<h3>Logging<a class="headerlink" href="#logging" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#logging'">¶</a></h3>
<p>The use of named logging levels can be traced back to the early days of UNIX, specifically to the syslog system, which was first introduced in the 1970s.
Syslog was a logging mechanism that allowed different programs to send log messages to a central system log, which could then be analyzed and monitored by system administrators.
Syslog introduced the concept of different logging levels, which were initially represented as numeric values from 0 to 7, with 0 being the most severe and 7 being the least severe.
Over time, these numeric values were replaced by named levels, which were easier to read and understand.
The tradition of using named logging levels has since been adopted by many logging frameworks and libraries, and is now a standard convention in the field of software engineering.</p>
<p>One of the most popular logging frameworks for C++ is called “spdlog”, which stands for “super fast C++ logging library”.
It is an open-source, header-only library that provides fast and flexible logging capabilities for C++ applications.
It supports various logging backends, such as console, file, and syslog, and provides features such as log rotation, thread-safety, and customizable formatting.
Spdlog has gained popularity in the C++ community due to its ease of use, performance, and compatibility with other libraries and frameworks.</p>
<p>The common logging levels, in increasing order of severity, are:</p>
<ul class="simple">
<li><p><strong>TRACE</strong>: Fine-grained informational events that are most useful to debug an application.</p></li>
<li><p><strong>DEBUG</strong>: Detailed debug information that can be useful to diagnose an application.</p></li>
<li><p><strong>INFO</strong>: Informational messages that highlight the progress of the application at a high level.</p></li>
<li><p><strong>WARN</strong>: Potentially harmful situations or unexpected events that do not prevent the application from working, but might require attention.</p></li>
<li><p><strong>ERROR</strong>: Error events that might still allow the application to continue running.</p></li>
<li><p><strong>FATAL</strong>: Severe error events that might cause the application to terminate.</p></li>
</ul>
<p>The following code shows how to use the logging levels in <strong>spdlog</strong>.
By default, a message is sent to <em>all</em> of the logging levels.
You can override the message by using one of the levels, e.g. <code class="docutils literal notranslate"><span class="pre">--debug</span> <span class="pre">"This</span> <span class="pre">is</span> <span class="pre">some</span> <span class="pre">debug</span> <span class="pre">text."</span></code>
In addition, you can specify the default level to show. In this case, the default level is set to “info” (corresponding to <strong>INFO</strong> above).
Only log messages written to this level or higher will actulaly be displayed.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">"CLI/CLI.hpp"</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">"spdlog/spdlog.h"</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">CLI</span><span class="o">::</span><span class="n">App</span><span class="w"> </span><span class="n">app</span><span class="p">(</span><span class="s">"CLI11 Logging Example"</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">trace_message</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">debug_message</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">info_message</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">warn_message</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">error_message</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">fatal_message</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// add options for each logging level</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">"--trace"</span><span class="p">,</span><span class="w"> </span><span class="n">trace_message</span><span class="p">,</span><span class="w"> </span><span class="s">"Log a trace message"</span><span class="p">);</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">"--debug"</span><span class="p">,</span><span class="w"> </span><span class="n">debug_message</span><span class="p">,</span><span class="w"> </span><span class="s">"Log a debug message"</span><span class="p">);</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">"--info"</span><span class="p">,</span><span class="w"> </span><span class="n">info_message</span><span class="p">,</span><span class="w"> </span><span class="s">"Log an info message"</span><span class="p">);</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">"--warn"</span><span class="p">,</span><span class="w"> </span><span class="n">warn_message</span><span class="p">,</span><span class="w"> </span><span class="s">"Log a warn message"</span><span class="p">);</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">"--error"</span><span class="p">,</span><span class="w"> </span><span class="n">error_message</span><span class="p">,</span><span class="w"> </span><span class="s">"Log an error message"</span><span class="p">);</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">"--fatal"</span><span class="p">,</span><span class="w"> </span><span class="n">fatal_message</span><span class="p">,</span><span class="w"> </span><span class="s">"Log a fatal message"</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// add option to set the log level</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">allowed_log_levels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">"trace"</span><span class="p">,</span><span class="w"> </span><span class="s">"debug"</span><span class="p">,</span><span class="w"> </span><span class="s">"info"</span><span class="p">,</span><span class="w"> </span><span class="s">"warn"</span><span class="p">,</span><span class="w"> </span><span class="s">"error"</span><span class="p">,</span><span class="w"> </span><span class="s">"fatal"</span><span class="p">};</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">log_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"info"</span><span class="p">;</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">"--log-level"</span><span class="p">,</span><span class="w"> </span><span class="n">log_level</span><span class="p">,</span><span class="w"> </span><span class="s">"Set the log level"</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">(</span><span class="n">CLI</span><span class="o">::</span><span class="n">IsMember</span><span class="p">(</span><span class="n">allowed_log_levels</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">default_val</span><span class="p">(</span><span class="n">log_level</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// parse the command line arguments</span>
<span class="w">    </span><span class="n">CLI11_PARSE</span><span class="p">(</span><span class="n">app</span><span class="p">,</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// configure the logger</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">logger</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spdlog</span><span class="o">::</span><span class="n">stdout_color_mt</span><span class="p">(</span><span class="s">"console"</span><span class="p">);</span>
<span class="w">    </span><span class="n">logger</span><span class="o">-&gt;</span><span class="n">set_level</span><span class="p">(</span><span class="n">spdlog</span><span class="o">::</span><span class="n">level</span><span class="o">::</span><span class="n">from_str</span><span class="p">(</span><span class="n">log_level</span><span class="p">));</span>

<span class="w">    </span><span class="c1">// log the message at the appropriate level</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">trace_message</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">SPDLOG_TRACE</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span><span class="w"> </span><span class="n">trace_message</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">debug_message</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">SPDLOG_DEBUG</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span><span class="w"> </span><span class="n">debug_message</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">info_message</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">SPDLOG_INFO</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span><span class="w"> </span><span class="n">info_message</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">warn_message</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">SPDLOG_WARN</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span><span class="w"> </span><span class="n">warn_message</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">error_message</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">SPDLOG_ERROR</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span><span class="w"> </span><span class="n">error_message</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">fatal_message</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">SPDLOG_CRITICAL</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span><span class="w"> </span><span class="n">fatal_message</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="essential-template-classes-in-stl">
<h3>Essential Template Classes in STL<a class="headerlink" href="#essential-template-classes-in-stl" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#essential-template-classes-in-stl'">¶</a></h3>
<p>The C++ Standard Template Library (STL) is a powerful (and comprehensive) set of template classes and functions, providing common data structures and algorithms. The STL is an integral part of the C++ Standard Library.</p>
<p>Let’s start with the most commonly needed <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> and <code class="docutils literal notranslate"><span class="pre">std::map</span></code>.</p>
<section id="std-vector-the-standard-all-in-one-vector-type">
<h4><code class="docutils literal notranslate"><span class="pre">std::vector</span></code>: The Standard All-in-One Vector Type<a class="headerlink" href="#std-vector-the-standard-all-in-one-vector-type" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">std::vector</span></code> is a dynamic all-in-one array data structure in C++ (similar to a Python list) that provides efficient memory management and flexible storage of elements, and it is important in scientific computing for its ability to handle large amounts of data efficiently.</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> is preferable to using a C pointer based equivalent array because it provides automatic memory management, better safety and convenience, and improved performance for dynamic resizing and storage of elements.</p>
<p>The advantages of using <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> therefore outweigh any disadvantages, especially if you care about the balance of performance and safety as we do.</p>
<p>The top 10 operations include:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">push_back()</span></code>: This function adds an element to the end of the vector.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pop_back()</span></code>: This function removes the last element from the vector.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size()</span></code>: This function returns the current number of elements in the vector.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">resize()</span></code>: This function resizes the vector to the specified number of elements. If the new size is larger than the current size, new elements are added with their default values. If the new size is smaller than the current size, excess elements are removed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clear()</span></code>: This function removes all elements from the vector.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">empty()</span></code>: This function returns true if the vector is empty, i.e., if it has no elements.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reserve()</span></code>: This function reserves space in the vector for a certain number of elements. This can be useful when you know the approximate size of the vector in advance and want to avoid frequent reallocations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">begin()</span></code> and end(): These functions return iterators that point to the first and one-past-the-last elements of the vector, respectively. You can use these iterators to traverse the elements of the vector.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">at()</span></code>: This function provides bounds checking when accessing elements of the vector. It throws an exception if the index is out of range.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator[]</span></code>: This function provides direct access to the elements of the vector using the square bracket notation. It does not perform bounds checking, so you need to be careful not to access elements out of range.</p></li>
</ul>
<p>In the following exmaple, we demonsrate the use of these most popular methods and use simple print statements to show that each method works as expected.</p>
<p>We make use of the built-in support for random number generation. Uniform random numbers are generated between 0.0 and 1.0.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;random&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fmt/core.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">random_device</span><span class="w"> </span><span class="n">rd</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">mt19937</span><span class="w"> </span><span class="n">gen</span><span class="p">(</span><span class="n">rd</span><span class="p">());</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dist</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// push_back()</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">dist</span><span class="p">(</span><span class="n">gen</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// size()</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"size: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

<span class="w">    </span><span class="c1">// resize()</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"size after resize: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

<span class="w">    </span><span class="c1">// reserve()</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"capacity after reserve: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">capacity</span><span class="p">());</span>

<span class="w">    </span><span class="c1">// clear()</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"size after clear: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

<span class="w">    </span><span class="c1">// empty()</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"vector is {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">"empty"</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">"not empty"</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// pop_back()</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">dist</span><span class="p">(</span><span class="n">gen</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// at()</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"first element: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"last element: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="mi">-1</span><span class="p">));</span>

<span class="w">    </span><span class="c1">// operator[]</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dist</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dist</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dist</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"first element: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"last element: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="mi">-1</span><span class="p">]);</span>

<span class="w">    </span><span class="c1">// iterators</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"{} "</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Your output may look like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">size</span><span class="p">:</span> <span class="mi">10</span>
<span class="n">size</span> <span class="n">after</span> <span class="n">resize</span><span class="p">:</span> <span class="mi">5</span>
<span class="n">capacity</span> <span class="n">after</span> <span class="n">reserve</span><span class="p">:</span> <span class="mi">20</span>
<span class="n">size</span> <span class="n">after</span> <span class="n">clear</span><span class="p">:</span> <span class="mi">0</span>
<span class="n">vector</span> <span class="ow">is</span> <span class="n">empty</span>
<span class="n">first</span> <span class="n">element</span><span class="p">:</span> <span class="mf">0.492471</span>
<span class="n">last</span> <span class="n">element</span><span class="p">:</span> <span class="mf">0.557134</span>
<span class="n">first</span> <span class="n">element</span><span class="p">:</span> <span class="mf">0.958176</span>
<span class="n">last</span> <span class="n">element</span><span class="p">:</span> <span class="mf">0.557134</span>
<span class="mf">0.958176</span> <span class="mf">0.334128</span> <span class="mf">0.031727</span> <span class="mf">0.228955</span> <span class="mf">0.983797</span> <span class="mf">0.0328053</span> <span class="mf">0.788841</span> <span class="mf">0.462369</span> <span class="mf">0.557134</span>
</pre></div>
</div>
<p>Testing using “print” statements is not ideal. Here is how to rewrite the above using unit tests:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;gtest/gtest.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;random&gt;</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">VectorTest</span><span class="p">,</span><span class="w"> </span><span class="n">PushBack</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">1.2</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">3.4</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">5.6</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">VectorTest</span><span class="p">,</span><span class="w"> </span><span class="n">Size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">1.2</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">3.4</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">5.6</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">VectorTest</span><span class="p">,</span><span class="w"> </span><span class="n">Empty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="n">ASSERT_TRUE</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">1.2</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT_FALSE</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">VectorTest</span><span class="p">,</span><span class="w"> </span><span class="n">Index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">1.2</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">3.4</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">5.6</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mf">3.4</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">VectorTest</span><span class="p">,</span><span class="w"> </span><span class="n">At</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">1.2</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">3.4</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">5.6</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mf">5.6</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="w">    </span><span class="n">ASSERT_THROW</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">VectorTest</span><span class="p">,</span><span class="w"> </span><span class="n">Iterator</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">1.2</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">3.4</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">5.6</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">3.4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">VectorTest</span><span class="p">,</span><span class="w"> </span><span class="n">Resize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">1.2</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">3.4</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">5.6</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">VectorTest</span><span class="p">,</span><span class="w"> </span><span class="n">PopBack</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">1.2</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">3.4</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">5.6</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mf">3.4</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">back</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">VectorTest</span><span class="p">,</span><span class="w"> </span><span class="n">Shuffle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">random_device</span><span class="w"> </span><span class="n">rd</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">mt19937</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="n">rd</span><span class="p">());</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">shuffle</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">g</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT_NE</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="std-map-the-standard-all-in-one-associative-array-dictionary-type">
<h4><code class="docutils literal notranslate"><span class="pre">std::map</span></code>: The Standard All-in-One Associative Array/Dictionary Type<a class="headerlink" href="#std-map-the-standard-all-in-one-associative-array-dictionary-type" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">std::map</span></code> is a dynamic all-in-one array data structure in C++ (similar to a Python dictionary) that supports an associative array, where keys of any type can be mapped to values of any type.</p>
<p>Here are the top 10 most common std::map methods and a brief explanation of their functionality:</p>
<ul class="simple">
<li><p><cite>insert()</cite>: Inserts an element into the map with the specified key-value pair.</p></li>
<li><p><cite>size()</cite>: Returns the number of elements in the map.</p></li>
<li><p><cite>empty()</cite>: Checks whether the map is empty.</p></li>
<li><p><cite>find()</cite>: Searches the map for an element with the specified key and returns an iterator to it, or returns end() if not found.</p></li>
<li><p><cite>operator[]</cite>: Accesses the element with the specified key, or inserts a new element with the default value if not found.</p></li>
<li><p><cite>erase()</cite>: Removes an element from the map with the specified key.</p></li>
<li><p><cite>count()</cite>: Counts the number of elements in the map with the specified key.</p></li>
<li><p><cite>clear()</cite>: Removes all elements from the map.</p></li>
<li><p><cite>begin()</cite>: Returns an iterator to the first element in the map.</p></li>
<li><p><cite>end()</cite>: Returns an iterator past the last element in the map.</p></li>
</ul>
<p>These methods provide essential functionality for managing key-value pairs in a map, and are widely used in various domains of programming, such as data processing, game development, and system programming, among others.</p>
<p>In the following exmaple, we demonsrate the use of these most popular methods and use simple print statements to show that each method works as expected.</p>
<p>We make use of the built-in support for random number generation. Uniform random numbers are generated between 0.0 and 1.0.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;map&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;random&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">random_device</span><span class="w"> </span><span class="n">rd</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">mt19937</span><span class="w"> </span><span class="n">gen</span><span class="p">(</span><span class="n">rd</span><span class="p">());</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dist</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// insert</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"one"</span><span class="p">,</span><span class="w"> </span><span class="n">dist</span><span class="p">(</span><span class="n">gen</span><span class="p">)));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"two"</span><span class="p">,</span><span class="w"> </span><span class="n">dist</span><span class="p">(</span><span class="n">gen</span><span class="p">)));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"three"</span><span class="p">,</span><span class="w"> </span><span class="n">dist</span><span class="p">(</span><span class="n">gen</span><span class="p">)));</span>

<span class="w">    </span><span class="c1">// size</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"size: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// empty</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"map is "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">"empty"</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">"not empty"</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// find</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"two"</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"value of key 'two': "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"key 'two' not found"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// operator[]</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"value of key 'three': "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">m</span><span class="p">[</span><span class="s">"three"</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// erase</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="s">"one"</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// count</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="s">"one"</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"count of key 'one': "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// clear</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"size after clear: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// iteration</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"one"</span><span class="p">,</span><span class="w"> </span><span class="n">dist</span><span class="p">(</span><span class="n">gen</span><span class="p">)));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"two"</span><span class="p">,</span><span class="w"> </span><span class="n">dist</span><span class="p">(</span><span class="n">gen</span><span class="p">)));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"three"</span><span class="p">,</span><span class="w"> </span><span class="n">dist</span><span class="p">(</span><span class="n">gen</span><span class="p">)));</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" =&gt; "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Your output may look like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">size</span><span class="p">:</span> <span class="mi">3</span>
<span class="nb">map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">empty</span>
<span class="n">value</span> <span class="n">of</span> <span class="n">key</span> <span class="s1">'two'</span><span class="p">:</span> <span class="mi">78</span>
<span class="n">value</span> <span class="n">of</span> <span class="n">key</span> <span class="s1">'three'</span><span class="p">:</span> <span class="mi">34</span>
<span class="n">count</span> <span class="n">of</span> <span class="n">key</span> <span class="s1">'one'</span><span class="p">:</span> <span class="mi">0</span>
<span class="n">size</span> <span class="n">after</span> <span class="n">clear</span><span class="p">:</span> <span class="mi">0</span>
<span class="n">one</span> <span class="o">=&gt;</span> <span class="mi">3</span>
<span class="n">three</span> <span class="o">=&gt;</span> <span class="mi">75</span>
<span class="n">two</span> <span class="o">=&gt;</span> <span class="mi">37</span>
</pre></div>
</div>
<p>Testing using “print” statements is not ideal. Here is how to rewrite the above using unit tests:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;gtest/gtest.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;map&gt;</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">MapTest</span><span class="p">,</span><span class="w"> </span><span class="n">Insert</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"one"</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"two"</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"three"</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">MapTest</span><span class="p">,</span><span class="w"> </span><span class="n">Size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"one"</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"two"</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"three"</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">MapTest</span><span class="p">,</span><span class="w"> </span><span class="n">Empty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="n">ASSERT_TRUE</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"one"</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="w">    </span><span class="n">ASSERT_FALSE</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">MapTest</span><span class="p">,</span><span class="w"> </span><span class="n">Find</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"one"</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"two"</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"three"</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"two"</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT_NE</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">it</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">MapTest</span><span class="p">,</span><span class="w"> </span><span class="n">Operator</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"one"</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"two"</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"three"</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">[</span><span class="s">"three"</span><span class="p">]);</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">[</span><span class="s">"four"</span><span class="p">]);</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">MapTest</span><span class="p">,</span><span class="w"> </span><span class="n">Erase</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"one"</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"two"</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"three"</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="s">"one"</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="s">"one"</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">MapTest</span><span class="p">,</span><span class="w"> </span><span class="n">Count</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"one"</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"two"</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"three"</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="s">"two"</span><span class="p">));</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="s">"four"</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">MapTest</span><span class="p">,</span><span class="w"> </span><span class="n">Clear</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"one"</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"two"</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"three"</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">    </span><span class="n">ASSERT_TRUE</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">MapTest</span><span class="p">,</span><span class="w"> </span><span class="n">Iteration</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"one"</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"two"</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"three"</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">"one"</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">"two"</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">"three"</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="other-useful-template-classes-beyond-std-vector-and-std-map">
<span id="index-0"></span><h3>Other Useful Template Classes beyond <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> and <code class="docutils literal notranslate"><span class="pre">std::map</span></code><a class="headerlink" href="#other-useful-template-classes-beyond-std-vector-and-std-map" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#other-useful-template-classes-beyond-std-vector-and-std-map'">¶</a></h3>
<p>There are several other essential modern template classes in the STL that are highly useful for various programming tasks. Many of these are useful to advanced systems programming, so we will introduce them briefly here and provide examples of each that are appropriate for our tutorial.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::array</span></code>: A container that encapsulates fixed-size arrays. It offers similar functionality to plain arrays but with added benefits of standard container functions like <code class="docutils literal notranslate"><span class="pre">.size()</span></code> and iterators.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::deque</span></code>: Double-ended queue that allows insertion and deletion at both ends. It’s useful when you need dynamic array behavior but with efficient insertion/removal from the front and back.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::list</span></code> and <code class="docutils literal notranslate"><span class="pre">std::forward_list</span></code>: Implementations of doubly-linked and singly-linked lists, respectively. They offer constant time insertion and deletion of elements but do not provide random access.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::set</span></code> and <code class="docutils literal notranslate"><span class="pre">std::multiset</span></code>: Containers that store unique elements following a specific order. <code class="docutils literal notranslate"><span class="pre">std::multiset</span></code> differs in allowing multiple elements to have equivalent values.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::unordered_set</span></code> and <code class="docutils literal notranslate"><span class="pre">std::unordered_multiset</span></code>: Implementations of hash set and multiset. They provide faster lookup, insertion, and deletion compared to <code class="docutils literal notranslate"><span class="pre">std::set</span></code>/<code class="docutils literal notranslate"><span class="pre">std::multiset`</span></code> at the cost of not maintaining order.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::stack</span></code> and <code class="docutils literal notranslate"><span class="pre">std::queue</span></code>: Adaptor containers. <code class="docutils literal notranslate"><span class="pre">std::stack</span></code> provides LIFO (last-in, first-out) data structure, and <code class="docutils literal notranslate"><span class="pre">std::queue</span></code> offers FIFO (first-in, first-out) data structure.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::priority_queue</span></code>: A container adaptor that provides constant time lookup of the largest (or smallest, if you customize) element.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::map</span></code> and <code class="docutils literal notranslate"><span class="pre">std::multimap</span></code>: Associative containers that store elements formed by a combination of a key value and a mapped value, following a specific order. The <code class="docutils literal notranslate"><span class="pre">std::multimap</span></code> allows multiple entries for a single key.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::unordered_map</span></code> and <code class="docutils literal notranslate"><span class="pre">std::unordered_multimap</span></code>: Implementations of hash map and hash multimap. They allow for faster access than <code class="docutils literal notranslate"><span class="pre">std::map</span></code>/ <code class="docutils literal notranslate"><span class="pre">std::multimap</span></code> but do not keep elements in any specific order.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::optional</span></code>: A wrapper for values that may or may not be present. Introduced in C++17, it’s useful for functions that may or may not return a value in a safe manner.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::variant</span></code>: Also introduced in C++17, this is a type-safe union class, which can hold one of several specified types but only one at a time.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::tuple</span></code>: A fixed-size collection of heterogeneous values. It’s a generalization of <code class="docutils literal notranslate"><span class="pre">std::pair</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::function</span></code>: A general-purpose polymorphic function wrapper. It can store, move, and invoke any Callable target—functions, lambda expressions, bind expressions, or other function objects.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::thread</span></code>: Represents a single thread of execution and introduced in C++11. It allows for more straightforward and portable multithreading.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::future</span></code> and <code class="docutils literal notranslate"><span class="pre">std::promise</span></code>: Introduced in C++11, these classes are used for asynchronous programming. They provide mechanisms to access the result of asynchronous operations.</p></li>
</ul>
<p>Understanding and effectively using these template classes can significantly enhance the efficiency, reliability, and readability of your C++ code. Each of these classes serves a particular purpose and can be chosen based on the specific requirements of your program.</p>
<p>In the remaining, we show minimium viable examples of these, while focusing on the most commonly used (5) methods.</p>
<section id="std-array-the-alternative-to-pointer-or-static-array-declarations">
<span id="index-1"></span><h4><code class="docutils literal notranslate"><span class="pre">std::array</span></code>: The alternative to pointer or static array declarations<a class="headerlink" href="#std-array-the-alternative-to-pointer-or-static-array-declarations" title="Permalink to this heading">¶</a></h4>
<p>This example demonstrates the basics of working with <code class="docutils literal notranslate"><span class="pre">std::array</span></code>.
It also demonstrates how to initialize it with an underlying pointer to an array.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;array&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">rawArray</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"First element: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Last element: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="w">    </span><span class="n">arr</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// Fill array with 5</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" "</span><span class="p">;</span><span class="w"> </span><span class="c1">// This uses a range expression on the underlying array</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">Size: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="std-deque-the-all-in-one-list-type">
<span id="index-2"></span><h4><code class="docutils literal notranslate"><span class="pre">std::deque</span></code>: The all-in-one list type<a class="headerlink" href="#std-deque-the-all-in-one-list-type" title="Permalink to this heading">¶</a></h4>
<p>A <em>deque</em> is a doubly-ended queue data structure.
It assures excellent performance when retrieving items from either side of the deque.</p>
<p>The following show how to insert items at either end and remove items from either end.
It also shows how to iterate the contents of the deque in natural order.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deque&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">};</span>

<span class="w">    </span><span class="n">dq</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">dq</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Front: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">dq</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Back: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">dq</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

<span class="w">    </span><span class="n">dq</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
<span class="w">    </span><span class="n">dq</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">dq</span><span class="p">)</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="std-forward-list-when-a-deque-is-not-needed">
<span id="index-3"></span><h4><code class="docutils literal notranslate"><span class="pre">std:forward_list</span></code>: When a <code class="docutils literal notranslate"><span class="pre">deque</span></code> is not needed<a class="headerlink" href="#std-forward-list-when-a-deque-is-not-needed" title="Permalink to this heading">¶</a></h4>
<p>If you do not need a <code class="docutils literal notranslate"><span class="pre">deque</span></code> and can do with a simple forward linked list, consider <code class="docutils literal notranslate"><span class="pre">std::forward_list</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;forward_list&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">forward_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">flst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">};</span>
<span class="w">    </span><span class="n">flst</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">flst</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Forward List: "</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">flst</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" "</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flst</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="c1">// Iterator to the start of the list</span>
<span class="w">    </span><span class="n">flst</span><span class="p">.</span><span class="n">insert_after</span><span class="p">(</span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// Insert '5' after the first element</span>
<span class="w">    </span><span class="n">flst</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// Removes all elements with the value '3'</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Modified Forward List: "</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">flst</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" "</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="std-set-the-ordered-set">
<span id="index-4"></span><h4><code class="docutils literal notranslate"><span class="pre">std::set</span></code>: The ordered set<a class="headerlink" href="#std-set-the-ordered-set" title="Permalink to this heading">¶</a></h4>
<p>This an example focusing only on <code class="docutils literal notranslate"><span class="pre">std::set</span></code> in C++ and highlight its top (10) commonly-used methods. <code class="docutils literal notranslate"><span class="pre">std::set</span></code> is a sorted associative container that contains unique elements.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;

int main() {
    std::set&lt;int&gt; s = {4, 1, 3, 5, 2};

    s.insert(6);
    s.erase(4);
    auto it = s.find(3);

    if (s.count(3)) {
        std::cout &lt;&lt; "3 is in the set\n";
    }

    std::cout &lt;&lt; "First element: " &lt;&lt; *s.begin() &lt;&lt; "\n";
    std::cout &lt;&lt; "Last element: " &lt;&lt; *s.rbegin() &lt;&lt; "\n";

    std::cout &lt;&lt; "Size: " &lt;&lt; s.size() &lt;&lt; "\n";

    if (!s.empty()) {
        std::cout &lt;&lt; "Set is not empty\n";
    }

    s.clear();

    // This shows how to re-initialize the set members (w/o constructor)
    s = {1, 2, 3, 4, 5};
    std::cout &lt;&lt; "Elements in set: ";
    for (const auto&amp; e : s) {
        std::cout &lt;&lt; e &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</pre></div>
</div>
</section>
<section id="std-multiset-the-ordered-set-that-keeps-count">
<span id="index-5"></span><h4><code class="docutils literal notranslate"><span class="pre">std::multiset</span></code>: The ordered set that keeps count<a class="headerlink" href="#std-multiset-the-ordered-set-that-keeps-count" title="Permalink to this heading">¶</a></h4>
<p>A std::multiset in C++ is similar to a std::set, but it allows multiple instances of the same value. This distinction enables some additional capabilities, particularly regarding element counts and handling of duplicates. Here’s an example showcasing std::multiset with a focus on its unique properties and methods:</p>
<p>This is a reworked version of the <code class="docutils literal notranslate"><span class="pre">set</span></code> example that highlights the additional capabilities of <code class="docutils literal notranslate"><span class="pre">multisset</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;set&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>

<span class="w">    </span><span class="n">ms</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// Inserts another '2' (hence the "muliti")</span>

<span class="w">    </span><span class="c1">// Erase elements by value (erases all instances)</span>
<span class="w">    </span><span class="n">ms</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Erases all elements with value '1'</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ms</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// Finds first element with value '3'</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Number of instances of 3: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ms</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

<span class="w">    </span><span class="n">ms</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">});</span><span class="w"> </span><span class="c1">// Inserts '5' twice and '6' once (hence the "multiset")</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Size: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ms</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">it_erase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ms</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">it_erase</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ms</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ms</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it_erase</span><span class="p">);</span><span class="w"> </span><span class="c1">// Erases one instance of '5'</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ms</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Multiset is not empty</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Elements in multiset: "</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ms</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" "</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="n">ms</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w"> </span><span class="c1">// Removes all elements</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="std-priority-queue-ordering-items-in-a-queue-by-a-given-priority-level">
<span id="index-6"></span><h4><code class="docutils literal notranslate"><span class="pre">std::priority_queue</span></code>: Ordering items in a queue by a given priority level<a class="headerlink" href="#std-priority-queue-ordering-items-in-a-queue-by-a-given-priority-level" title="Permalink to this heading">¶</a></h4>
<p>Priority queues are often used in systems.</p>
<p>To use a std::priority_queue to schedule jobs in Shortest Job First (SJF) fashion, you can create a priority queue that sorts jobs based on their length (in seconds). In SJF scheduling, the job with the shortest duration is selected next.</p>
<p>Here’s a basic example demonstrating this. First, we’ll define a Job struct that includes a job ID and its length in seconds. Then, we’ll use a std::priority_queue with a custom comparator to ensure that jobs with shorter lengths are given higher priority.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;queue&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Job</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="c1">// Length of the job in seconds</span>

<span class="w">    </span><span class="n">Job</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">id</span><span class="p">(</span><span class="n">id</span><span class="p">),</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="c1">// Define the &lt; operator for sorting. Inverse logic because priority_queue</span>
<span class="w">    </span><span class="c1">// is a max-heap by default, but we need a min-heap for SJF.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Job</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Priority queue for SJF scheduling</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">Job</span><span class="o">&gt;</span><span class="w"> </span><span class="n">jobQueue</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Add jobs to the queue</span>
<span class="w">    </span><span class="n">jobQueue</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// Job ID 1, length 5 seconds</span>
<span class="w">    </span><span class="n">jobQueue</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// Job ID 2, length 3 seconds</span>
<span class="w">    </span><span class="n">jobQueue</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// Job ID 3, length 10 seconds</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Job execution order (SJF): </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Process jobs in SJF order</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">jobQueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Job</span><span class="w"> </span><span class="n">currentJob</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jobQueue</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
<span class="w">        </span><span class="n">jobQueue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Job ID: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">currentJob</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", Length: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">currentJob</span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" seconds</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="std-optional-handling-situations-where-a-function-returns-or-fails-to-return-a-value">
<span id="index-7"></span><h4><code class="docutils literal notranslate"><span class="pre">std::optional</span></code>: Handling situations where a function returns or fails to return a value<a class="headerlink" href="#std-optional-handling-situations-where-a-function-returns-or-fails-to-return-a-value" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">std::optional</span></code> is a great choice for situations where a function might or might not return a value. In the context of reading a line of input, <code class="docutils literal notranslate"><span class="pre">std::optional</span></code> can be used to represent the outcome of the <em>read</em> operation: it contains a value if the read was successful, and it’s empty (<code class="docutils literal notranslate"><span class="pre">std::nullopt</span></code>) if the read failed (for example, if the end of file is reached).</p>
<p>Here’s an example of how you might use <code class="docutils literal notranslate"><span class="pre">std::optional</span></code> for reading a line from a file:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fstream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;optional&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">readLine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">line</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">line</span><span class="p">;</span><span class="w"> </span><span class="c1">// success</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span><span class="w"> </span><span class="c1">// fail</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="w"> </span><span class="n">file</span><span class="p">(</span><span class="s">"example.txt"</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Error opening file</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readLine</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Read line: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">line</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="a-look-at-expected-run-time-performance">
<span id="index-8"></span><h4>A Look at Expected Run-time Performance<a class="headerlink" href="#a-look-at-expected-run-time-performance" title="Permalink to this heading">¶</a></h4>
<p>Traditional algorithms and data structures courses emphasize the importance of time (and space) complexity.
While knowledge of these structures–and how to implement them–is still of value, it is vitallyimportant to know how make “good choices” when it comes to performance when it comes to the common methods avaiable in all classes.</p>
<p>The following table shows the expected time complexity when it comes to each of the standard library template classes. When left blank, it means that the method is either not available or not appropriate for the standard template class.</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">STL Containers Method Time Complexity [Prelimiary Analysis]</span><a class="headerlink" href="#id1" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 15%"/>
<col style="width: 11%"/>
<col style="width: 11%"/>
<col style="width: 11%"/>
<col style="width: 15%"/>
<col style="width: 15%"/>
<col style="width: 22%"/>
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>std::vector</p></th>
<th class="head"><p>std::deque</p></th>
<th class="head"><p>std::list</p></th>
<th class="head"><p>std::forward_list</p></th>
<th class="head"><p>std::set/multiset</p></th>
<th class="head"><p>std::unordered_set/multiset</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>size</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
</tr>
<tr class="row-odd"><td><p>empty</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
</tr>
<tr class="row-even"><td><p>insert</p></td>
<td><p>O(n)</p></td>
<td><p>O(1)*</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>O(log n)</p></td>
<td><p>O(1)*</p></td>
</tr>
<tr class="row-odd"><td><p>erase</p></td>
<td><p>O(n)</p></td>
<td><p>O(1)*</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>O(log n)</p></td>
<td><p>O(1)*</p></td>
</tr>
<tr class="row-even"><td><p>push_back</p></td>
<td><p>O(1)*</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>Not Applicable</p></td>
<td><p>Not Applicable</p></td>
<td><p>Not Applicable</p></td>
</tr>
<tr class="row-odd"><td><p>pop_back</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>Not Applicable</p></td>
<td><p>Not Applicable</p></td>
<td><p>Not Applicable</p></td>
</tr>
<tr class="row-even"><td><p>push_front</p></td>
<td><p>Not Applicable</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>Not Applicable</p></td>
<td><p>Not Applicable</p></td>
</tr>
<tr class="row-odd"><td><p>pop_front</p></td>
<td><p>Not Applicable</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>Not Applicable</p></td>
<td><p>Not Applicable</p></td>
</tr>
<tr class="row-even"><td><p>front</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>Not Applicable</p></td>
<td><p>Not Applicable</p></td>
</tr>
<tr class="row-odd"><td><p>back</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>Not Applicable</p></td>
<td><p>Not Applicable</p></td>
<td><p>Not Applicable</p></td>
</tr>
<tr class="row-even"><td><p>clear</p></td>
<td><p>O(n)</p></td>
<td><p>O(n)</p></td>
<td><p>O(n)</p></td>
<td><p>O(n)</p></td>
<td><p>O(n)</p></td>
<td><p>O(n)</p></td>
</tr>
<tr class="row-odd"><td><p>find</p></td>
<td><p>O(n)</p></td>
<td><p>O(n)</p></td>
<td><p>O(n)</p></td>
<td><p>O(n)</p></td>
<td><p>O(log n)</p></td>
<td><p>O(1)*</p></td>
</tr>
<tr class="row-even"><td><p>count</p></td>
<td><p>O(n)</p></td>
<td><p>O(n)</p></td>
<td><p>O(n)</p></td>
<td><p>O(n)</p></td>
<td><p>O(log n) + O(k)</p></td>
<td><p>O(1)*</p></td>
</tr>
<tr class="row-odd"><td><p>operator[]</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>Not Applicable</p></td>
<td><p>Not Applicable</p></td>
<td><p>Not Applicable</p></td>
<td><p>Not Applicable</p></td>
</tr>
<tr class="row-even"><td><p>at</p></td>
<td><p>O(1)</p></td>
<td><p>O(1)</p></td>
<td><p>Not Applicable</p></td>
<td><p>Not Applicable</p></td>
<td><p>Not Applicable</p></td>
<td><p>Not Applicable</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Entries with “Not Applicable” are for operations that do not apply to certain container types. For example, operations like <code class="docutils literal notranslate"><span class="pre">push_back</span></code> and <code class="docutils literal notranslate"><span class="pre">pop_back</span></code> are not applicable to associative containers (<code class="docutils literal notranslate"><span class="pre">std::set</span></code>, <code class="docutils literal notranslate"><span class="pre">std::multiset</span></code>, <code class="docutils literal notranslate"><span class="pre">std::unordered_set</span></code>, <code class="docutils literal notranslate"><span class="pre">std::unordered_multiset</span></code>) and <code class="docutils literal notranslate"><span class="pre">std::forward_list</span></code>.</p></li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>, operations such as <code class="docutils literal notranslate"><span class="pre">insert</span></code> and <code class="docutils literal notranslate"><span class="pre">erase</span></code> have a worst-case time complexity of <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> due to potential element shifting.</p></li>
<li><p>The asterisks indicate operations with amortized time complexity, particularly relevant for <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> and <code class="docutils literal notranslate"><span class="pre">std::unordered_set/multiset</span></code> where certain operations may involve occasional resizing or rehashing.</p></li>
</ul>
</section>
<section id="std-pair-and-std-tuple">
<h4><code class="docutils literal notranslate"><span class="pre">std::pair</span></code> and <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code><a class="headerlink" href="#std-pair-and-std-tuple" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">std::pair</span></code> and <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> are both utility classes in the C++ Standard Library that store a fixed set of elements, but they serve slightly different purposes.</p>
<p><code class="docutils literal notranslate"><span class="pre">std::pair</span></code> – a longstanding STL class – is specifically designed to store two elements, while std::tuple is more general and can store any number of elements.</p>
<p>Let’s begin with a simple example of <code class="docutils literal notranslate"><span class="pre">std::pair</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;utility&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Creating a pair of int and std::string</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myPair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">"Hello"</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Accessing elements</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"First: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myPair</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", Second: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myPair</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Modifying elements</span>
<span class="w">    </span><span class="n">myPair</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">myPair</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"World"</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"First: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myPair</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", Second: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myPair</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When you need to group more than two values together, consider <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tuple&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Creating a tuple of int, std::string, and float</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myTuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">"Hello"</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14f</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Accessing elements using std::get</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"First: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", Second: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", Third: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Modifying elements</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"World"</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.59f</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"First: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", Second: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", Third: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">std::pair</span></code> and <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> are both utility classes in the C++ Standard Library that store a fixed set of elements, but they serve slightly different purposes. <code class="docutils literal notranslate"><span class="pre">std::pair</span></code> is specifically designed to store two elements, while <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> is more general and can store any number of elements.</p>
<p>It is worth asking the question: Are <code class="docutils literal notranslate"><span class="pre">std::pair</span></code> and <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> Equivalent?</p>
<p>While <code class="docutils literal notranslate"><span class="pre">std::pair</span></code> and <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> can seem similar (especially since a <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> with two elements can act like a <code class="docutils literal notranslate"><span class="pre">std::pair</span></code>), they are <strong>not</strong> equivalent:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::pair</span></code> is limited to exactly two elements and is often used in contexts where two related values need to be grouped together, such as key-value pairs in maps.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> is more versatile and can hold any number of elements. It is useful in scenarios where you need to group a fixed, but arbitrary number of different types together.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">std::pair</span></code>, elements are accessed using <code class="docutils literal notranslate"><span class="pre">.first</span></code> and <code class="docutils literal notranslate"><span class="pre">.second</span></code>. In <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code>, elements are accessed using <code class="docutils literal notranslate"><span class="pre">std::get&lt;&gt;</span></code>, with the index of the element as a template parameter.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> can be seen as a generalization of <code class="docutils literal notranslate"><span class="pre">std::pair</span></code> but does not replace it, for pragmatic reasons.</p></li>
</ul>
<p>In summary, <code class="docutils literal notranslate"><span class="pre">std::pair</span></code> and <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> serve similar purposes but are not interchangeable. <code class="docutils literal notranslate"><span class="pre">std::pair</span></code> is simpler and more straightforward for handling pairs of elements, while <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> offers more flexibility and is suited for handling a fixed collection of several (greater than two in practice) elements.</p>
</section>
<section id="utility-functions-for-working-with-std-pair-and-std-tuple">
<span id="index-9"></span><h4>Utility Functions for working with <code class="docutils literal notranslate"><span class="pre">std::pair</span></code> and <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code><a class="headerlink" href="#utility-functions-for-working-with-std-pair-and-std-tuple" title="Permalink to this heading">¶</a></h4>
<p>In C++, <code class="docutils literal notranslate"><span class="pre">std::make_pair</span></code> is a utility function that simplifies the
creation of <code class="docutils literal notranslate"><span class="pre">std::pair</span></code> objects. It takes two arguments and returns a
<code class="docutils literal notranslate"><span class="pre">std::pair</span></code> constructed with those two values. This function is
particularly useful because it infers the types of the pair’s elements
from the types of the arguments passed to it, making the code more concise
and readable. For example, <code class="docutils literal notranslate"><span class="pre">std::make_pair(1,</span> <span class="pre">"Hello")</span></code> creates a
<code class="docutils literal notranslate"><span class="pre">std::pair&lt;int,</span> <span class="pre">std::string&gt;</span></code> without needing to explicitly specify these types.</p>
<p>On the other hand, <code class="docutils literal notranslate"><span class="pre">std::make_tuple</span></code> is used for creating <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> objects.
Similar to <code class="docutils literal notranslate"><span class="pre">std::make_pair</span></code>, it infers the types of the tuple’s elements from its arguments.
You can pass any number of arguments to <code class="docutils literal notranslate"><span class="pre">std::make_tuple</span></code>, and it will return a tuple
containing those values. For instance, <code class="docutils literal notranslate"><span class="pre">std::make_tuple(1,</span> <span class="pre">"Hello",</span> <span class="pre">3.14)</span></code>
will create a <code class="docutils literal notranslate"><span class="pre">std::tuple&lt;int,</span> <span class="pre">std::string,</span> <span class="pre">double&gt;</span></code>. This function is particularly
handy for creating tuples without having to explicitly specify the type of each element,
thus allowing for more concise and flexible code.</p>
</section>
<section id="converting-between-std-pair-and-std-tuple">
<span id="index-10"></span><h4>Converting between  <code class="docutils literal notranslate"><span class="pre">std::pair</span></code> and <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code><a class="headerlink" href="#converting-between-std-pair-and-std-tuple" title="Permalink to this heading">¶</a></h4>
<p>Here is how to convert a <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> to <code class="docutils literal notranslate"><span class="pre">std:pair</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tuple&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;utility&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myTuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">"Hello"</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Convert tuple to pair</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myPair</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">));</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Pair: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myPair</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myPair</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here is how to convert a <code class="docutils literal notranslate"><span class="pre">std::pair</span></code> to <code class="docutils literal notranslate"><span class="pre">std:tuple</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tuple&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;utility&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myPair</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">"Hello"</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Convert pair to tuple</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myTuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myPair</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Tuple: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p id="index-11">These can also be written using <code class="docutils literal notranslate"><span class="pre">auto</span></code> where the type information is automatically inferred:</p>
<p>Here is how to convert a <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> to <code class="docutils literal notranslate"><span class="pre">std:pair</span></code> using auto:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tuple&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;utility&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">myTuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">"Hello"</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Convert tuple to pair</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">myPair</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">));</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Pair: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myPair</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myPair</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here is how to convert a <code class="docutils literal notranslate"><span class="pre">std::pair</span></code> to <code class="docutils literal notranslate"><span class="pre">std:tuple</span></code> using auto:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tuple&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;utility&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">myPair</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">"Hello"</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Using auto to infer the type of std::tuple from std::pair</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">myTuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="p">(</span><span class="n">myPair</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Tuple: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="random-number-generation">
<h3>Random Number Generation<a class="headerlink" href="#random-number-generation" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#random-number-generation'">¶</a></h3>
<p>Scientific computing depends on random number generation in many domains.
We use it in a number of our programming examples.</p>
<p><code class="docutils literal notranslate"><span class="pre">std::mt19937</span></code> is one of the many built-in random number generators provided by the C++ standard library. Here are some of the other commonly used random number generators in the standard library.</p>
<p><code class="docutils literal notranslate"><span class="pre">std::default_random_engine</span></code>: This is a typedef that represents the default random number generator used by the standard library. Its exact implementation may vary between different implementations of the library.</p>
<p><code class="docutils literal notranslate"><span class="pre">std::minstd_rand0</span></code>: This is a simple linear congruential generator with a short period. It’s not recommended for serious use, but it’s provided for backwards compatibility with older code. We do not recommend using this one unless you have really good reasons for doing so.</p>
<p><code class="docutils literal notranslate"><span class="pre">std::minstd_rand</span></code>: This is a variant of std::minstd_rand0 with a longer period and better statistical properties.</p>
<p><code class="docutils literal notranslate"><span class="pre">std::mersenne_twister_engine</span></code>: This is the same generator as std::mt19937, but with a larger state size and a longer period. It’s generally considered to be one of the best random number generators available. This is what we use in our examples.</p>
<p><code class="docutils literal notranslate"><span class="pre">std::ranlux24_base</span></code>, <code class="docutils literal notranslate"><span class="pre">std::ranlux48_base</span></code>, <code class="docutils literal notranslate"><span class="pre">std::ranlux24</span></code>, <code class="docutils literal notranslate"><span class="pre">std::ranlux48</span></code>: These are a family of generators that use a lagged Fibonacci algorithm with a guaranteed long period. The 24 and 48 variants refer to the number of bits used for each number, and the _base variants use a simpler algorithm that’s faster but has a shorter period.</p>
<p>Each of these generators has its own strengths and weaknesses, so the choice of which one to use will depend on the specific needs of your program.</p>
<p>The following is an example of how to use random number generation to generate Point instances in all quandrants.
We use CLI11 to select the random number strategy.
We use lambda expressions to select points in each quadrant, subject to what the user specifies on the command line.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;algorithm&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;random&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">"point.h"</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">"CLI11.hpp"</span>

<span class="c1">// Define a helper function to filter the Points based on a predicate</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Predicate</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">filterPoints</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">points</span><span class="p">,</span><span class="w"> </span><span class="n">Predicate</span><span class="w"> </span><span class="n">pred</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">filteredPoints</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">copy_if</span><span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">points</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">filteredPoints</span><span class="p">),</span><span class="w"> </span><span class="n">pred</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">filteredPoints</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Define a helper function to print the Points in a vector</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">printPoints</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">points</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">":"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">points</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"("</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">getX</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">getY</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">")"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Define command line options for showing points in each quadrant.</span>
<span class="w">    </span><span class="c1">// An additional option, --rng, allows you to select the random number generator from two good choices.</span>
<span class="w">    </span><span class="n">CLI</span><span class="o">::</span><span class="n">App</span><span class="w"> </span><span class="n">app</span><span class="p">{</span><span class="s">"Quadrant filter"</span><span class="p">};</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">numPoints</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">"-n,--num-points"</span><span class="p">,</span><span class="w"> </span><span class="n">numPoints</span><span class="p">,</span><span class="w"> </span><span class="s">"Number of random points to generate"</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">showUpperRight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">showUpperLeft</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">showLowerRight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">showLowerLeft</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_flag</span><span class="p">(</span><span class="s">"-ur,--upper-right"</span><span class="p">,</span><span class="w"> </span><span class="n">showUpperRight</span><span class="p">,</span><span class="w"> </span><span class="s">"Show points in upper right quadrant"</span><span class="p">);</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_flag</span><span class="p">(</span><span class="s">"-ul,--upper-left"</span><span class="p">,</span><span class="w"> </span><span class="n">showUpperLeft</span><span class="p">,</span><span class="w"> </span><span class="s">"Show points in upper left quadrant"</span><span class="p">);</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_flag</span><span class="p">(</span><span class="s">"-lr,--lower-right"</span><span class="p">,</span><span class="w"> </span><span class="n">showLowerRight</span><span class="p">,</span><span class="w"> </span><span class="s">"Show points in lower right quadrant"</span><span class="p">);</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_flag</span><span class="p">(</span><span class="s">"-ll,--lower-left"</span><span class="p">,</span><span class="w"> </span><span class="n">showLowerLeft</span><span class="p">,</span><span class="w"> </span><span class="s">"Show points in lower left quadrant"</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">rngName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"mt19937"</span><span class="p">;</span>
<span class="w">    </span><span class="n">app</span><span class="p">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">"--rng"</span><span class="p">,</span><span class="w"> </span><span class="n">rngName</span><span class="p">,</span><span class="w"> </span><span class="s">"Random number generator to use (mt19937 or minstd_rand)"</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">([](</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">"mt19937"</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">"minstd_rand"</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">""</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">"Invalid random number generator"</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">    </span><span class="n">CLI11_PARSE</span><span class="p">(</span><span class="n">app</span><span class="p">,</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Generate a random number of Points with double coordinates</span>
<span class="w">    </span><span class="c1">// Note that randFunc is set to the random number generator selected, allowing us to switch the random number</span>
<span class="w">    </span><span class="c1">// generator easily. Others can be added without having to do major code changes.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">points</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">random_device</span><span class="w"> </span><span class="n">rd</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">randFunc</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rngName</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">"minstd_rand"</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">minstd_rand</span><span class="w"> </span><span class="nf">gen</span><span class="p">(</span><span class="n">rd</span><span class="p">());</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dis</span><span class="p">(</span><span class="mf">-10.0</span><span class="p">,</span><span class="w"> </span><span class="mf">10.0</span><span class="p">);</span>
<span class="w">        </span><span class="n">randFunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">dis</span><span class="p">,</span><span class="w"> </span><span class="n">gen</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">mt19937</span><span class="w"> </span><span class="nf">gen</span><span class="p">(</span><span class="n">rd</span><span class="p">());</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dis</span><span class="p">(</span><span class="mf">-10.0</span><span class="p">,</span><span class="w"> </span><span class="mf">10.0</span><span class="p">);</span>
<span class="w">        </span><span class="n">randFunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">dis</span><span class="p">,</span><span class="w"> </span><span class="n">gen</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numPoints</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">points</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">randFunc</span><span class="p">(),</span><span class="w"> </span><span class="n">randFunc</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Filter the Points that are in each quadrant using lambda expressions and helper functions</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">showUpperRight</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">isUpperRight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">getX</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">getY</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">upperRightPoints</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">filterPoints</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="w"> </span><span class="n">isUpperRight</span><span class="p">);</span>
<span class="w">        </span><span class="n">printPoints</span><span class="p">(</span><span class="n">upperRightPoints</span><span class="p">,</span><span class="w"> </span><span class="s">"Points in upper right quadrant"</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">showUpperLeft</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">isUpperLeft</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">getX</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">getY</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">upperLeftPoints</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">filterPoints</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="w"> </span><span class="n">isUpperLeft</span><span class="p">);</span>
<span class="w">        </span><span class="n">printPoints</span><span class="p">(</span><span class="n">upperLeftPoints</span><span class="p">,</span><span class="w"> </span><span class="s">"Points in upper left quadrant"</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">showLowerRight</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">isLowerRight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">getX</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">getY</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">lowerRightPoints</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">filterPoints</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="w"> </span><span class="n">isLowerRight</span><span class="p">);</span>
<span class="w">        </span><span class="n">printPoints</span><span class="p">(</span><span class="n">lowerRightPoints</span><span class="p">,</span><span class="w"> </span><span class="s">"Points in lower right quadrant"</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">showLowerLeft</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">isLowerLeft</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">getX</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">getY</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">lowerLeftPoints</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">filterPoints</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="w"> </span><span class="n">isLowerLeft</span><span class="p">);</span>
<span class="w">        </span><span class="n">printPoints</span><span class="p">(</span><span class="n">lowerLeftPoints</span><span class="p">,</span><span class="w"> </span><span class="s">"Points in lower left quadrant"</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="ranges">
<h3>Ranges<a class="headerlink" href="#ranges" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#ranges'">¶</a></h3>
<p>In this example, we use the <code class="docutils literal notranslate"><span class="pre">std::views::iota</span></code> function to create a range of integers from 1 to 10. We then use a range-based for loop to iterate over the range and print each value.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ranges&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">my_range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">iota</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">my_range</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" "</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ranges do not use any storage in the sense that they do not create a container to hold the elements of the range. Instead, ranges are defined as a pair of iterators or as a view that transforms or filters elements from an existing range.</p>
<p>Ranges operate lazily, which means that they do not compute the elements of the range until they are actually needed. This can make ranges more efficient than containers for certain operations, because the elements are computed on-the-fly rather than being stored in memory.</p>
<p>However, some range operations may require temporary storage to hold intermediate results or to cache the elements of the range. In such cases, the range may allocate memory to store these temporary results, but this is typically done behind the scenes and is not visible to the user.</p>
<p>In this example, we use the <code class="docutils literal notranslate"><span class="pre">std::views::filter</span></code> function to create a new view that filters the original range to include only the even numbers. We then use a range-based for loop to iterate over the filtered range and print each even number.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ranges&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">my_range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">iota</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">);</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">even_numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_range</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">filter</span><span class="p">([](</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">even_numbers</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" "</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ranges are still a work in progress in C++20, and support is inconsistent across compilers and operating systems.
Therefore, for more advanced, portable solutions, it is convenient to use the third-party library <a class="reference external" href="https://ericniebler.github.io/range-v3/">Range-v3</a>, which works with toolchains supporting C++14 and up and forms the basis for range support in C++20.</p>
<p>The following example is based on the <a class="reference external" href="https://adventofcode.com/2022/day/1">Advent of Code 2022 day one challenge</a>.
To summarize briefly, the input file consists of zero or more blocks of positive numbers, each on a separate line, separated by blank lines.
The task is to determine the up to three largest blocks of numbers with respect to the sum of their numbers, and determine the grand total of those (up to three) sums.</p>
<p>In terms of the original AoC sample input,</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>1000
2000
3000 &lt;- sum = 6000

4000 &lt;- sum = 4000

5000
6000 &lt;- sum = 11000

7000
8000
9000 &lt;- sum = 24000

10000 &lt;- sum = 10000
</pre></div>
</div>
<p>the fourth, third, and fifth block would be the three largest, with sums of 24,000, 11,000, and 10,000, respectively, and total sum of 45,000.
The answer consists of the largest sum and the grand total the three largest sums, i.e., the pair of 24,000 and 45,000.</p>
<p>Here is a solution in C++20 using Range-v3.
The main program converts successive lines to a vector of numbers, using 0 to represent empty lines.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">"rangev3-aoc2022day1.hpp"</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;utility&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;range/v3/view.hpp&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ranges</span><span class="p">;</span>

<span class="c1">// to use, redirect stdin from data/day1input.txt</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// read lines into vector&lt;int&gt; converting blank lines to zeroes</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getlines</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">views</span><span class="o">::</span><span class="n">transform</span><span class="p">([](</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w"> </span><span class="p">})</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">to_vector</span>
<span class="w">    </span><span class="p">;</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">views</span><span class="o">::</span><span class="n">all</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">most_nutritious_inventories</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Day 1 part 1 (max) = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Day 1 part 2 (sum) = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The core logic groups the flat vector into chunks terminated by, but not including, zeroes and then filters out any leftover chunks containing a zero.
It then replaces each chunk with the sum of its values in the form of a flattened vector, and uses <code class="docutils literal notranslate"><span class="pre">nth_element</span></code> to partially sort the vector in descending order but only down to the first n (i.e., three) elements.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">"rangev3-aoc2022day1.hpp"</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;utility&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;range/v3/view.hpp&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;range/v3/algorithm.hpp&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;range/v3/numeric.hpp&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ranges</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">most_nutritious_inventories</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// divide into chunks separated by one or more zeroes</span>
<span class="w">  </span><span class="c1">// then add up each chunk's calories</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">inventories</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="w"> </span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">views</span><span class="o">::</span><span class="n">chunk_by</span><span class="p">([](</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="p">})</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">views</span><span class="o">::</span><span class="n">filter</span><span class="p">([](</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">end</span><span class="p">(</span><span class="n">xs</span><span class="p">);</span><span class="w"> </span><span class="p">})</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">views</span><span class="o">::</span><span class="n">transform</span><span class="p">([](</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">accumulate</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="p">})</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">to_vector</span>
<span class="w">    </span><span class="p">;</span>

<span class="w">  </span><span class="c1">// return error value if there are fewer than n inventories</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">inventories</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// sort just enough in descending order to obtain largest n inventories</span>
<span class="w">  </span><span class="n">nth_element</span><span class="p">(</span><span class="n">inventories</span><span class="p">,</span><span class="w"> </span><span class="n">begin</span><span class="p">(</span><span class="n">inventories</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>

<span class="w">  </span><span class="c1">// return top and sum of top n inventory values</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">front</span><span class="p">(</span><span class="n">inventories</span><span class="p">),</span><span class="w"> </span><span class="n">accumulate</span><span class="p">(</span><span class="n">inventories</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">views</span><span class="o">::</span><span class="n">take</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that all lambdas involved in this example are pure in the sense that they aren’t closures that capture anything from their environment.</p>
<p>To appreciate the strong influence functional languages have had on C++ ranges, let’s take a look at a Scala 3 version of this example.
We first implement the extension method <code class="docutils literal notranslate"><span class="pre">splitWhere</span></code>, similar to <code class="docutils literal notranslate"><span class="pre">chunkBy</span></code> but without having to filter, which we can then use in a very similar pipeline as above.
<code class="docutils literal notranslate"><span class="pre">toIndexedSeq</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">to_vector</span></code>, and we are not aware of an efficient partial sorting method in Scala.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="cm">/** Partitions an iterator into chunks of consecutive elements for which the predicate holds. */</span>
<span class="k">extension</span><span class="w"> </span><span class="p">[</span><span class="nc">A</span><span class="p">](</span><span class="n">it</span><span class="p">:</span><span class="w"> </span><span class="nc">Iterator</span><span class="p">[</span><span class="nc">A</span><span class="p">])</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">splitWhere</span><span class="p">(</span><span class="n">p</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Iterator</span>
<span class="w">    </span><span class="p">.</span><span class="n">continually</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">takeWhile</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="w">    </span><span class="p">.</span><span class="n">takeWhile</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="n">hasNext</span><span class="p">)</span>

<span class="kd">val</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scala</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="nc">Source</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">getLines</span>

<span class="c1">// iterate over inventories of consecutive nonempty lines</span>
<span class="c1">// this stores only one Int per elf in memory</span>
<span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span>
<span class="w">    </span><span class="p">.</span><span class="n">splitWhere</span><span class="p">(</span><span class="n">_</span><span class="p">.</span><span class="n">nonEmpty</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">_</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">_</span><span class="p">.</span><span class="n">toInt</span><span class="p">).</span><span class="n">sum</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">toIndexedSeq</span>
<span class="w">    </span><span class="p">.</span><span class="n">sorted</span>
</pre></div>
</div>
</section>
<section id="threading">
<h3>Threading<a class="headerlink" href="#threading" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#threading'">¶</a></h3>
</section>
<section id="co-routines">
<h3>Co-routines<a class="headerlink" href="#co-routines" title="Permalink to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#co-routines'">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Co-routines are a fairly new C++ feature and may not be supported by your compiler. This is not needed for our oneAPI tutorial.</p>
</div>
<p>Co-routines are an important concept that is relevant to our discussion of SYCL and oneAPI.</p>
<p>A coroutine is a allows for the execution of multiple, independent, and cooperative subroutines or functions that can be paused and resumed at certain points to enable asynchronous or concurrent programming, without the overhead of creating multiple threads or processes.</p>
<p>Historically, the concept of coroutines was first introduced in the programming language Simula 67 – the language that introduced object-oriented programming – developed by Ole-Johan Dahl and Kristen Nygaard at the Norwegian Computing Center in Oslo, Norway in the mid-1960s.
The implementation of coroutines in Simula 67 was a bit different from the modern concept of coroutines, and the term “coroutine” itself was not used at that time.
The first programming language to use the term “coroutine” and to implement coroutines in a way that is closer to the modern concept was the programming language Modula-2, developed by Niklaus Wirth in the late 1970s.
After Modula-2, the next programming language to introduce support for coroutines was Ada, which added support for coroutines in the Ada 95 version of the language.</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kn">with</span> <span class="n">Ada.Text_IO</span><span class="p">;</span> <span class="kn">use</span> <span class="n">Ada.Text_IO</span><span class="p">;</span>
<span class="kn">with</span> <span class="n">Ada.Numerics.Float_Random</span><span class="p">;</span> <span class="kn">use</span> <span class="n">Ada.Numerics.Float_Random</span><span class="p">;</span>

<span class="kd">procedure</span> <span class="nf">Coroutine_Example</span> <span class="kr">is</span>

   <span class="kd">type</span> <span class="kt">Coroutine</span> <span class="kr">is</span> <span class="kr">access</span> <span class="kd">procedure</span><span class="p">;</span> <span class="c1">-- define a type for a coroutine</span>

   <span class="kd">task</span> <span class="kd">type</span> <span class="kt">Coroutine_Task</span> <span class="kr">is</span> <span class="c1">-- define a task type for a coroutine</span>
      <span class="kd">entry</span> <span class="nf">Start</span><span class="p">(</span><span class="nv">C</span> <span class="p">: </span><span class="nv">in</span> <span class="nv">Coroutine</span><span class="p">);</span> <span class="c1">-- an entry to start the coroutine</span>
   <span class="kr">end</span> <span class="nf">Coroutine_Task</span><span class="p">;</span>

   <span class="n">Sum</span> <span class="p">:</span> <span class="kt">Float</span> <span class="p">:=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="c1">-- shared variable to accumulate the sum</span>
   <span class="no">Num_Coroutines</span> <span class="p">:</span> <span class="kr">constant</span> <span class="kt">Integer</span> <span class="p">:=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">-- number of coroutines</span>

   <span class="c1">-- define the coroutine procedure</span>
   <span class="kd">procedure</span> <span class="nf">My_Coroutine</span> <span class="kr">is</span>
      <span class="n">R</span> <span class="p">:</span> <span class="n">Float_Random</span><span class="p">.</span><span class="kt">Generator</span><span class="p">;</span> <span class="c1">-- random number generator</span>
      <span class="no">X</span> <span class="p">:</span> <span class="kr">constant</span> <span class="kt">Float</span> <span class="p">:=</span> <span class="n">Float_Random</span><span class="p">.</span><span class="n">Random</span><span class="p">(</span><span class="n">R</span><span class="p">);</span> <span class="c1">-- compute a random number</span>
   <span class="kr">begin</span>
      <span class="n">Put_Line</span><span class="p">(</span><span class="s">"Coroutine started, X = "</span> <span class="o">&amp;</span> <span class="kt">Float</span><span class="p">'</span><span class="na">Image</span><span class="p">(</span><span class="n">X</span><span class="p">));</span>
      <span class="n">Sum</span> <span class="p">:=</span> <span class="n">Sum</span> <span class="o">+</span> <span class="n">X</span><span class="p">;</span> <span class="c1">-- add X to the sum</span>
   <span class="kr">end</span> <span class="nf">My_Coroutine</span><span class="p">;</span>

   <span class="c1">-- array of coroutines</span>
   <span class="n">Coroutines</span> <span class="p">:</span> <span class="kr">array</span> <span class="p">(</span><span class="mf">1.</span><span class="p">.</span><span class="n">Num_Coroutines</span><span class="p">)</span> <span class="kr">of</span> <span class="n">Coroutine</span><span class="p">;</span>

   <span class="c1">-- array of coroutine tasks</span>
   <span class="kd">Task</span><span class="n">s</span> <span class="p">:</span> <span class="kr">array</span> <span class="p">(</span><span class="mf">1.</span><span class="p">.</span><span class="n">Num_Coroutines</span><span class="p">)</span> <span class="kr">of</span> <span class="n">Coroutine_Task</span><span class="p">;</span>

<span class="kr">begin</span>

   <span class="c1">-- create the coroutines and their tasks</span>
   <span class="kr">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="mf">1.</span><span class="p">.</span><span class="n">Num_Coroutines</span> <span class="kr">loop</span>
      <span class="n">Coroutines</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="p">:=</span> <span class="n">My_Coroutine</span><span class="p">'</span><span class="na">Access</span><span class="p">;</span> <span class="c1">-- create a coroutine</span>
      <span class="kd">Task</span><span class="n">s</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="p">:=</span> <span class="kr">new</span> <span class="n">Coroutine_Task</span><span class="p">;</span> <span class="c1">-- create a task for the coroutine</span>
      <span class="kd">Task</span><span class="n">s</span><span class="p">(</span><span class="n">I</span><span class="p">).</span><span class="n">Start</span><span class="p">(</span><span class="n">Coroutines</span><span class="p">(</span><span class="n">I</span><span class="p">));</span> <span class="c1">-- start the task, passing the coroutine as parameter</span>
   <span class="kr">end</span> <span class="kr">loop</span><span class="p">;</span>

   <span class="c1">-- wait for all tasks to complete</span>
   <span class="kr">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="mf">1.</span><span class="p">.</span><span class="n">Num_Coroutines</span> <span class="kr">loop</span>
      <span class="kc">null</span><span class="p">;</span>
   <span class="kr">end</span> <span class="kr">loop</span><span class="p">;</span>

   <span class="c1">-- print the final result</span>
   <span class="n">Put_Line</span><span class="p">(</span><span class="s">"Sum = "</span> <span class="o">&amp;</span> <span class="kt">Float</span><span class="p">'</span><span class="na">Image</span><span class="p">(</span><span class="n">Sum</span><span class="p">));</span>

<span class="kr">end</span> <span class="nf">Coroutine_Example</span><span class="p">;</span>
</pre></div>
</div>
<p>Co-routines have become popular in many recent language designs, notably Go. Here is what a co-routine looks like in Go.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">"fmt"</span>
<span class="w">    </span><span class="s">"math/rand"</span>
<span class="w">    </span><span class="s">"time"</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">coroutine</span><span class="p">(</span><span class="nx">ch</span><span class="w"> </span><span class="kd">chan</span><span class="o">&lt;-</span><span class="w"> </span><span class="kt">float64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">r</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">rand</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nx">NewSource</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">UnixNano</span><span class="p">()))</span><span class="w"> </span><span class="c1">// create a random number generator</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">r</span><span class="p">.</span><span class="nx">Float64</span><span class="p">()</span><span class="w"> </span><span class="c1">// compute a random number</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">"Coroutine started, x = %f\n"</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">)</span>
<span class="w">    </span><span class="nx">ch</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="c1">// send the result back to the main program</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">sum</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="c1">// shared variable to accumulate the sum</span>
<span class="w">    </span><span class="nx">numCoroutines</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="c1">// number of coroutines</span>
<span class="w">    </span><span class="nx">ch</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">float64</span><span class="p">)</span><span class="w"> </span><span class="c1">// create a channel for communication</span>

<span class="w">    </span><span class="c1">// start the coroutines</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">numCoroutines</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">go</span><span class="w"> </span><span class="nx">coroutine</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// wait for all coroutines to complete and accumulate the results</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">numCoroutines</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">ch</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// print the final result</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">"Sum = %f\n"</span><span class="p">,</span><span class="w"> </span><span class="nx">sum</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While our course is about C++, it is important to realize that many modern C++ features are greatly influenced by the other modern languages (and forms of expression) around them.
The ability to write co-routines and use <em>blocking</em> channels to exchange results between the co-routine and the main program demonstrate a high level of awareness that allows programmers to express concurrency clearly and concisely.</p>
<p>Modern co-routines, therefore, allow not only for the expression of concurrency but also for the elegant transmission of data to and from the co-routine. There are some similarities with how SYCL supports these concepts using <em>accessors</em>. We’ll speak to this again when introducing SYCL.</p>
<p>Let’s take a look at how C++ introduces co-routines.
The following shows how to create four co-routines that sleep for random amounts of time and join at the end?</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;chrono&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;random&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;coroutine&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>

<span class="c1">// A simple coroutine that sleeps for a random amount of time</span>
<span class="c1">// and returns the amount of time slept</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SleepCoroutine</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">SleepCoroutine</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// The coroutine promise type</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">promise_type</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">get_return_object</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">SleepCoroutine</span><span class="p">{</span><span class="n">handle_type</span><span class="o">::</span><span class="n">from_promise</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)};</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">suspend_never</span><span class="w"> </span><span class="n">initial_suspend</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">{};</span><span class="w"> </span><span class="p">}</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span><span class="w"> </span><span class="n">final_suspend</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">{};</span><span class="w"> </span><span class="p">}</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">unhandled_exception</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">terminate</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">return_void</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// The coroutine handle type</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">handle_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// The coroutine execution function</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">operator</span><span class="p">()()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Generate a random sleep time</span>
<span class="w">     </span><span class="n">std</span><span class="o">::</span><span class="n">random_device</span><span class="w"> </span><span class="n">rd</span><span class="p">;</span>
<span class="w">     </span><span class="n">std</span><span class="o">::</span><span class="n">mt19937</span><span class="w"> </span><span class="n">gen</span><span class="p">(</span><span class="n">rd</span><span class="p">());</span>
<span class="w">     </span><span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">distr</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="mi">5000</span><span class="p">);</span>
<span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="n">sleep_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">distr</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>

<span class="w">     </span><span class="c1">// Sleep for the random time</span>
<span class="w">     </span><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">SleepCoroutine</span><span class="p">(</span><span class="n">handle_type</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">handle</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="n">handle_type</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// A function that creates and runs four sleep coroutines</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">run_sleep_coroutines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Create a vector to hold the coroutines</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SleepCoroutine</span><span class="o">::</span><span class="n">handle_type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">coroutines</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Create and start the coroutines</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">coroutines</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">SleepCoroutine</span><span class="p">{}());</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Join the coroutines</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">coroutine</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">coroutines</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">coroutine</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
<span class="w">        </span><span class="n">coroutine</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// The main function</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">run_sleep_coroutines</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"All coroutines joined."</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>
</div></div><aside class="hidden text-sm xl:block" id="right-sidebar">
<div class="sticky top-16 -mt-10 max-h-[calc(var(--vh)-4rem)] overflow-y-auto pt-6 space-y-2"><p class="font-medium">On this page</p>
<ul>
<li><a :data-current="activeSection === '#overview-of-modern-c'" class="reference internal" href="#overview-of-modern-c">Overview of Modern C++</a></li>
<li><a :data-current="activeSection === '#language-features'" class="reference internal" href="#language-features">Language Features</a><ul>
<li><a :data-current="activeSection === '#the-modern-c-class'" class="reference internal" href="#the-modern-c-class">The Modern C++ Class</a></li>
<li><a :data-current="activeSection === '#move-semantics'" class="reference internal" href="#move-semantics">Move Semantics</a></li>
<li><a :data-current="activeSection === '#lambda-expressions'" class="reference internal" href="#lambda-expressions">Lambda Expressions</a><ul>
<li><a :data-current="activeSection === '#basic-lambda-with-no-parameters'" class="reference internal" href="#basic-lambda-with-no-parameters">Basic Lambda with No Parameters</a></li>
<li><a :data-current="activeSection === '#lambda-with-parameters'" class="reference internal" href="#lambda-with-parameters">Lambda with Parameters</a></li>
<li><a :data-current="activeSection === '#lambda-with-explicit-return-type'" class="reference internal" href="#lambda-with-explicit-return-type">Lambda with Explicit Return Type</a></li>
<li><a :data-current="activeSection === '#lambda-with-closures'" class="reference internal" href="#lambda-with-closures">Lambda with Closures</a></li>
</ul>
</li>
<li><a :data-current="activeSection === '#naming-conventions'" class="reference internal" href="#naming-conventions">Naming Conventions</a></li>
<li><a :data-current="activeSection === '#adding-this-to-a-cmake-folder'" class="reference internal" href="#adding-this-to-a-cmake-folder">Adding this to a CMake folder</a></li>
<li><a :data-current="activeSection === '#automatic-variables'" class="reference internal" href="#automatic-variables">Automatic variables</a></li>
<li><a :data-current="activeSection === '#constants-and-constant-expressions'" class="reference internal" href="#constants-and-constant-expressions">Constants and Constant Expressions</a></li>
<li><a :data-current="activeSection === '#initializer-expressions'" class="reference internal" href="#initializer-expressions">initializer expressions</a></li>
<li><a :data-current="activeSection === '#format-and-fmt'" class="reference internal" href="#format-and-fmt">Format and fmt</a></li>
<li><a :data-current="activeSection === '#command-line-argument-handling'" class="reference internal" href="#command-line-argument-handling">Command-line Argument Handling</a></li>
<li><a :data-current="activeSection === '#better-generics-for-mathematical-functions'" class="reference internal" href="#better-generics-for-mathematical-functions">Better Generics for Mathematical Functions</a></li>
<li><a :data-current="activeSection === '#logging'" class="reference internal" href="#logging">Logging</a></li>
<li><a :data-current="activeSection === '#essential-template-classes-in-stl'" class="reference internal" href="#essential-template-classes-in-stl">Essential Template Classes in STL</a><ul>
<li><a :data-current="activeSection === '#std-vector-the-standard-all-in-one-vector-type'" class="reference internal" href="#std-vector-the-standard-all-in-one-vector-type"><code class="docutils literal notranslate"><span class="pre">std::vector</span></code>: The Standard All-in-One Vector Type</a></li>
<li><a :data-current="activeSection === '#std-map-the-standard-all-in-one-associative-array-dictionary-type'" class="reference internal" href="#std-map-the-standard-all-in-one-associative-array-dictionary-type"><code class="docutils literal notranslate"><span class="pre">std::map</span></code>: The Standard All-in-One Associative Array/Dictionary Type</a></li>
</ul>
</li>
<li><a :data-current="activeSection === '#other-useful-template-classes-beyond-std-vector-and-std-map'" class="reference internal" href="#other-useful-template-classes-beyond-std-vector-and-std-map">Other Useful Template Classes beyond <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> and <code class="docutils literal notranslate"><span class="pre">std::map</span></code></a><ul>
<li><a :data-current="activeSection === '#std-array-the-alternative-to-pointer-or-static-array-declarations'" class="reference internal" href="#std-array-the-alternative-to-pointer-or-static-array-declarations"><code class="docutils literal notranslate"><span class="pre">std::array</span></code>: The alternative to pointer or static array declarations</a></li>
<li><a :data-current="activeSection === '#std-deque-the-all-in-one-list-type'" class="reference internal" href="#std-deque-the-all-in-one-list-type"><code class="docutils literal notranslate"><span class="pre">std::deque</span></code>: The all-in-one list type</a></li>
<li><a :data-current="activeSection === '#std-forward-list-when-a-deque-is-not-needed'" class="reference internal" href="#std-forward-list-when-a-deque-is-not-needed"><code class="docutils literal notranslate"><span class="pre">std:forward_list</span></code>: When a <code class="docutils literal notranslate"><span class="pre">deque</span></code> is not needed</a></li>
<li><a :data-current="activeSection === '#std-set-the-ordered-set'" class="reference internal" href="#std-set-the-ordered-set"><code class="docutils literal notranslate"><span class="pre">std::set</span></code>: The ordered set</a></li>
<li><a :data-current="activeSection === '#std-multiset-the-ordered-set-that-keeps-count'" class="reference internal" href="#std-multiset-the-ordered-set-that-keeps-count"><code class="docutils literal notranslate"><span class="pre">std::multiset</span></code>: The ordered set that keeps count</a></li>
<li><a :data-current="activeSection === '#std-priority-queue-ordering-items-in-a-queue-by-a-given-priority-level'" class="reference internal" href="#std-priority-queue-ordering-items-in-a-queue-by-a-given-priority-level"><code class="docutils literal notranslate"><span class="pre">std::priority_queue</span></code>: Ordering items in a queue by a given priority level</a></li>
<li><a :data-current="activeSection === '#std-optional-handling-situations-where-a-function-returns-or-fails-to-return-a-value'" class="reference internal" href="#std-optional-handling-situations-where-a-function-returns-or-fails-to-return-a-value"><code class="docutils literal notranslate"><span class="pre">std::optional</span></code>: Handling situations where a function returns or fails to return a value</a></li>
<li><a :data-current="activeSection === '#a-look-at-expected-run-time-performance'" class="reference internal" href="#a-look-at-expected-run-time-performance">A Look at Expected Run-time Performance</a></li>
<li><a :data-current="activeSection === '#std-pair-and-std-tuple'" class="reference internal" href="#std-pair-and-std-tuple"><code class="docutils literal notranslate"><span class="pre">std::pair</span></code> and <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code></a></li>
<li><a :data-current="activeSection === '#utility-functions-for-working-with-std-pair-and-std-tuple'" class="reference internal" href="#utility-functions-for-working-with-std-pair-and-std-tuple">Utility Functions for working with <code class="docutils literal notranslate"><span class="pre">std::pair</span></code> and <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code></a></li>
<li><a :data-current="activeSection === '#converting-between-std-pair-and-std-tuple'" class="reference internal" href="#converting-between-std-pair-and-std-tuple">Converting between  <code class="docutils literal notranslate"><span class="pre">std::pair</span></code> and <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code></a></li>
</ul>
</li>
<li><a :data-current="activeSection === '#random-number-generation'" class="reference internal" href="#random-number-generation">Random Number Generation</a></li>
<li><a :data-current="activeSection === '#ranges'" class="reference internal" href="#ranges">Ranges</a></li>
<li><a :data-current="activeSection === '#threading'" class="reference internal" href="#threading">Threading</a></li>
<li><a :data-current="activeSection === '#co-routines'" class="reference internal" href="#co-routines">Co-routines</a></li>
</ul>
</li>
</ul>
</div>
</aside>
</main>
</div>
</div><footer class="py-6 border-t border-border md:py-0">
<div class="container flex flex-col items-center justify-between gap-4 md:h-24 md:flex-row">
<div class="flex flex-col items-center gap-4 px-8 md:flex-row md:gap-2 md:px-0">
<p class="text-sm leading-loose text-center text-muted-foreground md:text-left">© 2013-2019, UnoAPI Software Systems Laboratory Built with <a class="font-medium underline underline-offset-4" href="https://www.sphinx-doc.org" rel="noreferrer">Sphinx 6.2.1</a></p>
</div>
</div>
</footer>
</div>
</body>
</html>