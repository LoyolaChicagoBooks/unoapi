
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Marching Cubes: From CUDA to SYCL &#8212; UnoAPI: Modern Parallel C++ Programming with SYCL and oneAPI v0.6</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=466cad66"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '92-marching-cubes/marching-cubes';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Electron Density Case Study" href="../93-electron-density/electron-density.html" />
    <link rel="prev" title="Code of Conduct" href="../91-coc/code-of-conduct.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  

  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">UnoAPI: Modern Parallel C++ Programming with SYCL and oneAPI v0.6</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../00-preliminaries/preliminaries.html">About the Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05-parallel/parallel.html">Introduction to Parallel Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10-software-engineering/software-engineering.html">Introduction to Software Engineering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15-modern-cpp/modern-cpp.html">Modern C++ as a Better C (and C++)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18-dpcpp/dpcpp.html">Data-Parallel C++ with oneAPI/SYCL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20-quant-finance/qfi.html">Quantitative Finance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../30-performance/performance.html">Performance Essentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../80-running/running.html">Compiling and Running oneAPI programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../90-contributions/contributions.html">Contribution Guildelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../91-coc/code-of-conduct.html">Code of Conduct</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Marching Cubes: From CUDA to SYCL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../93-electron-density/electron-density.html">Electron Density Case Study</a></li>
<li class="toctree-l1"><a class="reference internal" href="../99-chapter-template/chapter-title.html">Chapter Title</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/92-marching-cubes/marching-cubes.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Marching Cubes: From CUDA to SYCL</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-brief-cuda-reivew">A Brief CUDA Reivew</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#kernels-being-used">Kernels Being Used</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cuda-vs-sycl-implementations">CUDA vs SYCL Implementations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#classify-voxel-kernel-cuda">Classify Voxel Kernel - CUDA:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#classify-voxel-kernel-sycl">Classify Voxel Kernel - SYCL</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compact-voxels-kernel-cuda">Compact Voxels Kernel - CUDA</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compact-voxels-kernel-sycl">Compact Voxels Kernel - SYCL</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generate-triangles-kernel-cuda">Generate Triangles Kernel - CUDA:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generate-triangles-kernel-sycl">Generate Triangles Kernel - SYCL:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#use-of-thrust-library-in-cuda-implementation">Use of Thrust Library in CUDA Implementation:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#use-onedpl-thrust-equivalent-in-sycl">Use oneDPL (Thrust Equivalent) in SYCL:</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="marching-cubes-from-cuda-to-sycl">
<h1>Marching Cubes: From CUDA to SYCL<a class="headerlink" href="#marching-cubes-from-cuda-to-sycl" title="Link to this heading">#</a></h1>
<p>This Gist provides a walkthrough of the marching cubes algorithm
implemented in CUDA. The code can be found in its entirety here (enter
hyperlink later). We start by briefly reviewing how parallelization
works in CUDA. We then take a look at some of the key kernels being used
in a CUDA implementation of the marching cubes algorithm. Those CUDA
kernels are then put through the SYCLomatic tool, a tool developed to
aid in the porting of code from other languages to SYCL. We then clean
up the output of the SYCLomatic tool into a final working version of
SYCL kernels.</p>
<section id="a-brief-cuda-reivew">
<h2>A Brief CUDA Reivew<a class="headerlink" href="#a-brief-cuda-reivew" title="Link to this heading">#</a></h2>
<p>CUDA enables parallelization by allowing the programmer to define a
kernel that is executed by a large numberof threads concurrently. Each
thread processes a small portion of the data, and the collective work of
all threads achieves the overall computation. The combination of thread
and block indices allows each thread to work on a unique subset of the
data, thus ensuring that the entire dataset is processed in parallel. …
more stuff about how cuda works</p>
</section>
<section id="kernels-being-used">
<h2>Kernels Being Used<a class="headerlink" href="#kernels-being-used" title="Link to this heading">#</a></h2>
<p>List them here</p>
</section>
<section id="cuda-vs-sycl-implementations">
<h2>CUDA vs SYCL Implementations<a class="headerlink" href="#cuda-vs-sycl-implementations" title="Link to this heading">#</a></h2>
<section id="classify-voxel-kernel-cuda">
<h3>Classify Voxel Kernel - CUDA:<a class="headerlink" href="#classify-voxel-kernel-cuda" title="Link to this heading">#</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">classifyVoxel</span></code> kernel classifies each voxel in a 3D grid based on
the number of vertices it will generate. Let’s breakdown how it works:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">classifyVoxel</span><span class="p">(</span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelVerts</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">uchar</span><span class="w"> </span><span class="o">*</span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSize</span><span class="p">,</span>
<span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">,</span><span class="w"> </span><span class="n">float3</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">numVertsTex</span><span class="p">,</span><span class="w"> </span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">volumeTex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Calculate the unique index for this thread within the entire grid</span>
<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Compute the position in the 3D grid</span>
<span class="w">    </span><span class="n">uint3</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calcGridPos</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">);</span>

<span class="w">    </span><span class="c1">//Read field values at the 8 neighboring grid vertices</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="p">,</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Calculate a falg indicating if each vertex is inside of outside the isosurface</span>
<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">);</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span>

<span class="w">    </span><span class="c1">//Read the number of vertices from the texture</span>
<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">numVerts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tex1Dfetch</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numVertsTex</span><span class="p">,</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// If the voxel index is within bounds, store the number of vertices and occupancy</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">voxelVerts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numVerts</span><span class="p">;</span>
<span class="w">        </span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">numVerts</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Print the results to verify the SYCL equivalent kernel produces the same results</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Voxel %u: numVerts=%u, occupied=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">numVerts</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The kernel starts by assigning each thread a uinque index <code class="docutils literal notranslate"><span class="pre">i</span></code> by
calculating <code class="docutils literal notranslate"><span class="pre">blockId</span></code> and multiplying it by the number of threads per
block. This index <code class="docutils literal notranslate"><span class="pre">i</span></code> corresponds to a specific voxel in the grid.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
<p>The 1D index <code class="docutils literal notranslate"><span class="pre">i</span></code> is then converted to a 3D grid position <code class="docutils literal notranslate"><span class="pre">gridPos</span></code>
by using the <code class="docutils literal notranslate"><span class="pre">calcGridPos</span></code> function. This is needed for locating the
voxel’s position in the 3D volume.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">uint3</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calcGridPos</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">);</span>
</pre></div>
</div>
<p>The field values at the eight corners of the voxel are then sampled
using the <code class="docutils literal notranslate"><span class="pre">sampleVolume</span></code> function, which accesses the volume data
through the texture object <code class="docutils literal notranslate"><span class="pre">volumeTex</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="p">,</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</pre></div>
</div>
<p>Each corner’s field value then needs to be compared to the <code class="docutils literal notranslate"><span class="pre">isoValue</span></code>.
If if field value is less than the <code class="docutils literal notranslate"><span class="pre">isoValue</span></code>, the corresponding bit
in <code class="docutils literal notranslate"><span class="pre">cubeindex</span></code> is set. The <code class="docutils literal notranslate"><span class="pre">cubeindex</span></code> thus forms a unique
identifier representing the voxel’s classification.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">uint</span><span class="w"> </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">);</span>
<span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
<span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>
<span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span>
</pre></div>
</div>
<p>The number of vertices for the given <code class="docutils literal notranslate"><span class="pre">cubeindex</span></code> is then fetched from
the texure <code class="docutils literal notranslate"><span class="pre">numVertsTex</span></code>. This lookup is essential for determining how
many vertices the voxel will generate.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">uint</span><span class="w"> </span><span class="n">numVerts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tex1Dfetch</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numVertsTex</span><span class="p">,</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">);</span>
</pre></div>
</div>
<p>Lastly, the voxel index <code class="docutils literal notranslate"><span class="pre">i</span></code> is checked to see if it within bounds. If
it is, the numberof vertices and occupancy status are stored in
<code class="docutils literal notranslate"><span class="pre">voxelVerts</span></code> and <code class="docutils literal notranslate"><span class="pre">voxelOccupied</span></code> arrays, respectively.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">voxelVerts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numVerts</span><span class="p">;</span>
<span class="w">    </span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">numVerts</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>We also print the voxel index, number of vertices, and occupancy status,
as we will check this output against a SYCL equivalent kernel later.</p>
</section>
<section id="classify-voxel-kernel-sycl">
<h3>Classify Voxel Kernel - SYCL<a class="headerlink" href="#classify-voxel-kernel-sycl" title="Link to this heading">#</a></h3>
<p>Below we can see the output of SYCLomatic when converting the above CUDA
kernel to SYCL. While the tool gets the programmer very far in the
porting process, you will see that it is not 100% porting solution, and
some portions of the code need to be manually addressed.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">classifyVoxel</span><span class="p">(</span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelVerts</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">uchar</span><span class="w"> </span><span class="o">*</span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSize</span><span class="p">,</span>
<span class="w">                   </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">,</span>
<span class="w">                   </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">isoValue</span><span class="p">,</span>
<span class="w">                   </span><span class="n">dpct</span><span class="o">::</span><span class="n">image_accessor_ext</span><span class="o">&lt;</span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">numVertsTex</span><span class="p">,</span>
<span class="w">                   </span><span class="n">dpct</span><span class="o">::</span><span class="n">image_accessor_ext</span><span class="o">&lt;</span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">volumeTex</span><span class="p">,</span>
<span class="w">                   </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item_ct1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_id</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calcGridPos</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">);</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="p">,</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>

<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">);</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span>

<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">numVerts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tex1Dfetch</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numVertsTex</span><span class="p">,</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">voxelVerts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numVerts</span><span class="p">;</span>
<span class="w">        </span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">numVerts</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Voxel %u: numVerts=%u, occupied=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">numVerts</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">launch_classifyVoxel</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelVerts</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">uchar</span><span class="w"> </span><span class="o">*</span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSize</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">dpct</span><span class="o">::</span><span class="n">get_in_order_queue</span><span class="p">().</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cgh</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">numVertsTex_acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">dpct</span><span class="o">::</span><span class="n">image_wrapper</span><span class="o">&lt;</span>
<span class="w">            </span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">numVertsTex</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">get_access</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">volumeTex_acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">dpct</span><span class="o">::</span><span class="n">image_wrapper</span><span class="o">&lt;</span>
<span class="w">            </span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">get_access</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>

<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">numVertsTex_smpl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numVertsTex</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">get_sampler</span><span class="p">();</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">volumeTex_smplt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">volumeTex</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">get_sampler</span><span class="p">();</span>

<span class="w">        </span><span class="n">cgh</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">classifyVoxel</span><span class="p">(</span>
<span class="w">                </span><span class="n">voxelVerts</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridSize</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span>
<span class="w">                </span><span class="n">gridSizeMask</span><span class="p">,</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">,</span><span class="w"> </span><span class="n">isoValue</span><span class="p">,</span>
<span class="w">                </span><span class="n">dpct</span><span class="o">::</span><span class="n">image_accessor_ext</span><span class="o">&lt;</span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">                    </span><span class="n">numVertsTex_smpl</span><span class="p">,</span><span class="w"> </span><span class="n">numVertsTex_acc</span><span class="p">),</span>
<span class="w">                </span><span class="n">dpct</span><span class="o">::</span><span class="n">image_accessor_ext</span><span class="o">&lt;</span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">                    </span><span class="n">volumeTex_smpl</span><span class="p">,</span><span class="w"> </span><span class="n">volumeTex_acc</span><span class="p">),</span>
<span class="w">                </span><span class="n">item_ct1</span><span class="p">);</span>
<span class="w">        </span><span class="p">});</span>
<span class="w">    </span><span class="p">});</span>

<span class="w">    </span><span class="n">getLastCudaError</span><span class="p">(</span><span class="s">&quot;classifyVoxel failed&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Thread and Block Indices:</strong></p>
<p>SYCLomatic uses SYCL’s <code class="docutils literal notranslate"><span class="pre">nd_iem</span></code> to handle thread and block indices,
analogous to CUDA’s <code class="docutils literal notranslate"><span class="pre">blockIdx</span></code>, <code class="docutils literal notranslate"><span class="pre">threadIdx</span></code>, and <code class="docutils literal notranslate"><span class="pre">blockDim</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct2</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_id</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Grid Position Calculation:</strong></p>
<p>The function <code class="docutils literal notranslate"><span class="pre">calcGridPos</span></code> remains unchanged and works the same way as
in CUDA.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calcGridPos</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Field Value Sampling:</strong></p>
<p>The texture access functions are replaces by SYCL equivalents.
<code class="docutils literal notranslate"><span class="pre">sampleVolume</span></code> is called the same way as in CUDA.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="p">,</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p><strong>Isosurface Classification and Number of Vertices Lookup</strong></p>
<p>The operations for comparing field values and fetching the number of
vertices are similar in SYCL.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">uint</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">;</span>
<span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">);</span>
<span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
<span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>
<span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span>
<span class="n">uint</span><span class="w"> </span><span class="n">numVerts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tex1Dfetch</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numVertsTex</span><span class="p">,</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">);</span>
</pre></div>
</div>
<p>The code for storing the results and printing remains the same.</p>
</section>
<section id="compact-voxels-kernel-cuda">
<h3>Compact Voxels Kernel - CUDA<a class="headerlink" href="#compact-voxels-kernel-cuda" title="Link to this heading">#</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">compactVoxels</span></code> kernel is crucial for compacting the voxel arrary
by eliminating empty voxels and creating a contiguous array of active
voxels.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">compactVoxels</span><span class="p">(</span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">compactedVoxelArray</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupiedScan</span><span class="p">,</span>
<span class="w">                                                                              </span><span class="n">uint</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">compactedVoxelArray</span><span class="p">[</span><span class="n">voxelOccupiedScan</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Compact voxel %u: compactedIndex=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupiedScan</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Thread and Block Indices</strong></p>
<p>CUDA organizes threads into blocks and blocks into grids. Each thread
has a unique index within its block, and each block has a unique index
within the grid.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">blockIdx.y</span></code> and <code class="docutils literal notranslate"><span class="pre">blockIdx.x</span></code> are the block indices in the y and
x dimensions of the grid.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gridDim.x</span></code> is the number of blocks in the x dimension.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">blockDim.x</span></code> is the number of threads in a block.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">threadIdx.x</span></code> is the thread index within the block.</p></li>
</ul>
<p>The global thread index <code class="docutils literal notranslate"><span class="pre">i</span></code> is computed to uniquely identify each
thread’s work item.</p>
<p><strong>Compaction Condition:</strong> - Each thread checks if the voxel at index
<code class="docutils literal notranslate"><span class="pre">i</span></code> is occupied and if <code class="docutils literal notranslate"><span class="pre">i</span></code> is within our bounds.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">voxelOccupied[i]</span></code> is a boolean array indicating whether the voxel
at index <code class="docutils literal notranslate"><span class="pre">i</span></code> is occupied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numVoxels</span></code> is the total number of voxels.</p></li>
</ul>
<p><strong>Compaction Operation</strong> If the voxel is occupied, the kernel writes the
voxel’s index to the <code class="docutils literal notranslate"><span class="pre">compactedVoxelArray</span></code> at the position specified
by <code class="docutils literal notranslate"><span class="pre">voxelOccupiedScan[i]</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">compactedVoxelArray</span><span class="p">[</span><span class="n">voxelOccupiedScan</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">voxelOccupiedScan</span></code> is an array that contains the result of the
prefix sum operation on <code class="docutils literal notranslate"><span class="pre">voxelOccupied</span></code>. It provides the position
in the compacted array for each occupied voxel.</p></li>
</ul>
<p>We again have the kernel print the voxel index and its new compacted
index to check this against the SYCL version.</p>
</section>
<section id="compact-voxels-kernel-sycl">
<h3>Compact Voxels Kernel - SYCL<a class="headerlink" href="#compact-voxels-kernel-sycl" title="Link to this heading">#</a></h3>
<p>This is the output of the above CUDA kernel when put through SYCLomatic.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">compactVoxels</span><span class="p">(</span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">compactedVoxelArray</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupiedScan</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">,</span>
<span class="w">                   </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item_ct1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_id</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">compactedVoxelArray</span><span class="p">[</span><span class="n">voxelOccupiedScan</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Compact voxel %u: compactedIndex=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupiedScan</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">launch_compactVoxels</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">compactedVoxelArray</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupiedScan</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">dpct</span><span class="o">::</span><span class="n">get_in_order_queue</span><span class="p">().</span><span class="n">parllel_for</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">),</span>
<span class="w">                                           </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">compactVoxels</span><span class="p">(</span><span class="n">compactedVoxelArray</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupiedScan</span><span class="p">,</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">,</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>

<span class="w">    </span><span class="n">getLastCudaError</span><span class="p">(</span><span class="s">&quot;compactVoxels failed&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Thread and Block Indices</strong></p>
<p>We again see that SYCLomatic uses SYCL’s <code class="docutils literal notranslate"><span class="pre">nd_item</span></code> to handle thread
and block indices, just as CUDA would use <code class="docutils literal notranslate"><span class="pre">blockIdx</span></code>, <code class="docutils literal notranslate"><span class="pre">threadIdx</span></code>,
and <code class="docutils literal notranslate"><span class="pre">blockDim</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_id</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Compaction Condition and Operation</strong></p>
<p>The compaction condition and operation are directly translated to SYCL,
maintaining the same logic as in CUDA.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">compactedVoxelArray</span><span class="p">[</span><span class="n">voxelOccupiedScan</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Kernel Launch</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">launch_compactVoxels</span></code> function in SYCL uses
<code class="docutils literal notranslate"><span class="pre">dpct::get_in_order_queue().parallel_for</span></code> to submit the kernel for
execution (talk more about the extern C stuff…)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">launch_compactVoxels</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">compactedVoxelArray</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupiedScan</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">dpct</span><span class="o">::</span><span class="n">get_in_order_queue</span><span class="p">().</span><span class="n">parallel_for</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">),</span>
<span class="w">                                            </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">compactVoxels</span><span class="p">(</span><span class="n">compactedVoxelArray</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupiedScan</span><span class="p">,</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">,</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>

<span class="w">    </span><span class="n">getLastCudaError</span><span class="p">(</span><span class="s">&quot;compactVoxels failed&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="generate-triangles-kernel-cuda">
<h3>Generate Triangles Kernel - CUDA:<a class="headerlink" href="#generate-triangles-kernel-cuda" title="Link to this heading">#</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">generateTriangles</span></code> kernel is the heart of the marching cubes
algorithm, responsible for generating the actual triangles that form the
isosurface. This kernel takes the compacted voxel array and, for each
active voxel, generates the necessary vertices and normals for the
triangles.</p>
<p>The kernel starts by assigning each thread a unique index <code class="docutils literal notranslate"><span class="pre">i</span></code> by
calculating <code class="docutils literal notranslate"><span class="pre">blockId</span></code> and multiplying it by the number of threads per
block. This index <code class="docutils literal notranslate"><span class="pre">i</span></code> corresponds to a specific voxel in the compacted
voxel array.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">generateTriangles</span><span class="p">(</span><span class="n">float4</span><span class="w"> </span><span class="o">*</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="o">*</span><span class="n">norm</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">compactedVoxelArray</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">numVertsScanned</span><span class="p">,</span>
<span class="w">                                  </span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSize</span><span class="p">,</span><span class="w"> </span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">,</span><span class="w"> </span><span class="n">float3</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">,</span>
<span class="w">                                  </span><span class="kt">float</span><span class="w"> </span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">activeVoxels</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">maxVerts</span><span class="p">,</span><span class="w"> </span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">triTex</span><span class="p">,</span>
<span class="w">                                  </span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">numvertsTex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">activeVoxels</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">activeVoxels</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">voxel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compactedVoxelArray</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="n">uint3</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calcGridPos</span><span class="p">(</span><span class="n">voxel</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">);</span>

<span class="w">    </span><span class="n">float3</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.0f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">gridPos</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.0f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">gridPos</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.0f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">gridPos</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>

<span class="w">    </span><span class="n">float3</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_float3</span><span class="p">(</span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_float3</span><span class="p">(</span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_float3</span><span class="p">(</span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_float3</span><span class="p">(</span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>

<span class="w">    </span><span class="n">float4</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>

<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">);</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span>

<span class="w">    </span><span class="n">float3</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="w">    </span><span class="n">float3</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>

<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>

<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">9</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">11</span><span class="p">]);</span>

<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">numVerts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tex1Dfetch</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numVertsTex</span><span class="p">,</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVerts</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">uint</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tex1Dfetch</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">triTex</span><span class="p">,</span><span class="w"> </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="n">uint</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numVertsScanned</span><span class="p">[</span><span class="n">voxel</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maxVerts</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pos</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_float4</span><span class="p">(</span><span class="n">vertlist</span><span class="p">[</span><span class="n">edge</span><span class="p">],</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>
<span class="w">            </span><span class="n">norm</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_float4</span><span class="p">(</span><span class="n">normlist</span><span class="p">[</span><span class="n">edge</span><span class="p">],</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The first step in the kernel is to calculate the unique index for the
thread within the entire grid. This index <code class="docutils literal notranslate"><span class="pre">i</span></code> is used to fetch the
voxel index from the compacted voxel array.</p>
<p>The kernel then computes the 3D grid position of the voxel using the
<code class="docutils literal notranslate"><span class="pre">calcGridPos</span></code> function. This 3D position is necessary to determine the
coordinates of the voxel’s corners in the volume.</p>
<p>The positions of the voxel’s eight corners are calculated relative to
the 3D grid position and the voxel size. These positions are stored in
the <code class="docutils literal notranslate"><span class="pre">v</span></code> array.</p>
<p>Next, the field values at these eight corners are evaluated using the
<code class="docutils literal notranslate"><span class="pre">fieldFunc4</span></code> function, which returns both the field value and its
gradient at each corner. These values are stored in the <code class="docutils literal notranslate"><span class="pre">field</span></code> array.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">cubeindex</span></code> is then calcualted by comparing each field value to
the isovalue. The <code class="docutils literal notranslate"><span class="pre">cubeindex</span></code> is a unique identifier representing the
classification of the voxel based on the isovalue.</p>
<p>The vertices where the isosurface intersects the cube edges are computed
using the <code class="docutils literal notranslate"><span class="pre">vertexInterp2</span></code> function. This function interpolates the
positions and normals of the vertices along the edges of the cube. These
vertices are stored in the <code class="docutils literal notranslate"><span class="pre">vertlist</span></code> and <code class="docutils literal notranslate"><span class="pre">normlist</span></code> arrays,
respectively.</p>
<p>The number of vertiecs for the given <code class="docutils literal notranslate"><span class="pre">cubeindex</span></code> is fetched from the
<code class="docutils literal notranslate"><span class="pre">numVertsTex</span></code> texture. This value indicates how many verties are
needed to form the triangles for this voxel.</p>
<p>Finally, the kerne. iterates over the required number of vertices,
fetching the corresponding edge indices from the <code class="docutils literal notranslate"><span class="pre">triTex</span></code> texture. It
then writes the positions and normals of these verties to the output
arrays <code class="docutils literal notranslate"><span class="pre">pos</span></code> and <code class="docutils literal notranslate"><span class="pre">norm</span></code>.</p>
</section>
<section id="generate-triangles-kernel-sycl">
<h3>Generate Triangles Kernel - SYCL:<a class="headerlink" href="#generate-triangles-kernel-sycl" title="Link to this heading">#</a></h3>
<p>When we use SYCLomatic to convert the above into SYCL, the
<code class="docutils literal notranslate"><span class="pre">generateTriangles</span></code> kernel retains the same logic but adapts to the
SYCL programming model. Here is the output:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">generateTriangles</span><span class="p">(</span><span class="n">float4</span><span class="w"> </span><span class="o">*</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="o">*</span><span class="n">norm</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">compactedVoxelArray</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">numVertsScanned</span><span class="p">,</span>
<span class="w">                       </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSize</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">,</span>
<span class="w">                       </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">activeVoxels</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">maxVerts</span><span class="p">,</span>
<span class="w">                       </span><span class="n">dpct</span><span class="o">::</span><span class="n">image_accessor_ext</span><span class="o">&lt;</span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">triTex</span><span class="p">,</span>
<span class="w">                       </span><span class="n">dpct</span><span class="o">::</span><span class="n">image_accessor_ext</span><span class="o">&lt;</span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">numVertsTex</span><span class="p">,</span>
<span class="w">                       </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item_ct1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_Ct1</span><span class="p">.</span><span class="n">get_local_id</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">activeVoxels</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">activeVoxels</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">voxel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compactedVoxelArray</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calcGridPos</span><span class="p">(</span><span class="n">voxel</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">);</span>

<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.0f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">gridPos</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.0f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">gridPos</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.0f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">gridPos</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>

<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="p">(</span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="p">(</span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="p">(</span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="p">(</span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>

<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">float4</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
<span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>

<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">);</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>
<span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span>

<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>

<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>

<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">9</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>
<span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">11</span><span class="p">]);</span>

<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">numVerts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tex1Dfeth</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numVertsTex</span><span class="p">,</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVerts</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">uint</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tex1Dfetch</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">triTex</span><span class="p">,</span><span class="w"> </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="n">uint</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numVertsScanned</span><span class="p">[</span><span class="n">voxel</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maxVerts</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pos</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_float4</span><span class="p">(</span><span class="n">vertlist</span><span class="p">[</span><span class="n">edge</span><span class="p">],</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>
<span class="w">            </span><span class="n">norm</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_float4</span><span class="p">(</span><span class="n">normlist</span><span class="p">[</span><span class="n">edge</span><span class="p">],</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">launch_generateTriangles</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="o">*</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="o">*</span><span class="n">norm</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">compactedVoxelArray</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">numVertsScanned</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSize</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">,</span>
<span class="w">                                         </span><span class="kt">float</span><span class="w"> </span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">activeVoxels</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">maxVerts</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">dpct</span><span class="o">::</span><span class="n">get_in_order_queue</span><span class="p">().</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cgh</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">triTex_acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">dpct</span><span class="o">::</span><span class="n">image_wrapper</span><span class="o">&lt;</span>
<span class="w">            </span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">triTex</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">get_access</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">numVertsTex_acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">dpct</span><span class="o">::</span><span class="n">image_wrapper</span><span class="o">&lt;</span>
<span class="w">            </span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">numVertsTex</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">get_access</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>

<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">triTex_smpl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">triTex</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">get_sampler</span><span class="p">();</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">numVertsTex_smpl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numVertsTex</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">get_sampler</span><span class="p">();</span>

<span class="w">        </span><span class="n">cgh</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">generateTriangles</span><span class="p">(</span>
<span class="w">                </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">norm</span><span class="p">,</span><span class="w"> </span><span class="n">compactedVoxelArray</span><span class="p">,</span><span class="w"> </span><span class="n">numVertsScanned</span><span class="p">,</span><span class="w"> </span><span class="n">gridSize</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">,</span>
<span class="w">                </span><span class="n">voxelSize</span><span class="p">,</span><span class="w"> </span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">activeVoxels</span><span class="p">,</span><span class="w"> </span><span class="n">maxVerts</span><span class="p">,</span>
<span class="w">                </span><span class="n">dpct</span><span class="o">::</span><span class="n">image_accessor_ext</span><span class="o">&lt;</span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">triTex_smpl</span><span class="p">,</span><span class="w"> </span><span class="n">triTex_acc</span><span class="p">),</span>
<span class="w">                </span><span class="n">dpct</span><span class="o">::</span><span class="n">image_accessor_ext</span><span class="o">&lt;</span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">                    </span><span class="n">numVertsTex_smpl</span><span class="p">,</span><span class="w"> </span><span class="n">numVertsTex_acc</span><span class="p">),</span>
<span class="w">                </span><span class="n">item_ct1</span><span class="p">);</span>
<span class="w">        </span><span class="p">});</span>
<span class="w">    </span><span class="p">});</span>

<span class="w">    </span><span class="n">getLastCudaError</span><span class="p">(</span><span class="s">&quot;generateTriangles failed&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In SYCL, the logi of the kernel remains the same, but the API calls and
syntax are changed to be compatible with the SYCL framework. The use of
<code class="docutils literal notranslate"><span class="pre">dpct::image_accessor_ext</span></code> for texture accesses and <code class="docutils literal notranslate"><span class="pre">sycl::nd_item</span></code>
for thread and block indices are notable chagnes. (MORE ON THIS SECTION
LATER)</p>
</section>
<section id="use-of-thrust-library-in-cuda-implementation">
<h3>Use of Thrust Library in CUDA Implementation:<a class="headerlink" href="#use-of-thrust-library-in-cuda-implementation" title="Link to this heading">#</a></h3>
<p><strong>Understanding Prefix Sum Operations</strong></p>
<p>Beofre diving into how the Thrust library is used in the CUDA
implementation, it is essential to understand what prefix sum operations
are and why they are crucial in parallel algorithms.</p>
<p><strong>What is a Prefix Sum?</strong></p>
<p>A prefix sum, also known as a scan operation, is an operation that takes
an input array and produces an output array were each element at index
<code class="docutils literal notranslate"><span class="pre">i</span></code> is the sum of all the elements from the start of the input array
up to, but not including, the element at index <code class="docutils literal notranslate"><span class="pre">i</span></code>. In mathematical
terms, given an input array <code class="docutils literal notranslate"><span class="pre">A</span></code>, the prefix sum array <code class="docutils literal notranslate"><span class="pre">B</span></code> is defined
as:</p>
<div class="math notranslate nohighlight">
\[B[i] = \sum_{j=0}^{i} A[j]\]</div>
<p>For example, if the input array <code class="docutils literal notranslate"><span class="pre">A</span></code> is:</p>
<div class="math notranslate nohighlight">
\[A=[3,1,4,1,5,9,2,6,5]\]</div>
<p>then the prefix sum array <code class="docutils literal notranslate"><span class="pre">B</span></code> would be:</p>
<div class="math notranslate nohighlight">
\[B=[0,3,4,8,9,14,23,25,31]\]</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">B[0]</span></code> is 0 because there are no elements before the first
element of <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B[1]</span></code> is 3 which is just <code class="docutils literal notranslate"><span class="pre">A[0]</span></code>, <code class="docutils literal notranslate"><span class="pre">B[2]</span></code> is 4
which is <code class="docutils literal notranslate"><span class="pre">A[0]</span> <span class="pre">+</span> <span class="pre">A[1]</span></code>, and so on.</p>
<p>Prefix sums are a fundamental building block in parallel algorithms.
They are used in a variety of applications such as stream compaction,
sorting, and building data structures like histograms and cumulative
distributions. The prefix sum operation is inherently parallelizable
because each element in the output array can be computed independently
once the partial sums are known.</p>
<p>In our marching cubes algorithm, the prefix sum operation is used to
compact the voxel array. After classifying the voxels, we need to know
how many voxels are occupied up to each point in the array to
efficiently generate the triangles. This is where the prefix sum comes
into play.</p>
<p>After classifying each voxel as occupied or empty, we have an array
<code class="docutils literal notranslate"><span class="pre">voxelOccupied</span></code> where each element is a flag indicating whether a
voxel is occupied. We need to compact this array to remove the empty
voxels and create a contiguous array of occupied voxels. The prerfix sum
operation on the <code class="docutils literal notranslate"><span class="pre">voxelOccupied</span></code> array allows us to achieve this.</p>
<p>Using the prefix sum operation on the <code class="docutils literal notranslate"><span class="pre">voxelOccupied</span></code> array results in
the <code class="docutils literal notranslate"><span class="pre">voxelOccupiedScan</span></code> array. This array contains the running total
of occupied voxels up to each point. By using this array, we can
determine the position of each occupied voxel in the compacted array.</p>
<p><strong>Using Thrust in the CUDA Implementation</strong></p>
<p>Thrust is a parlalel algorithms library in CUDA that resembes the C++
Standard Template Library (STL). It provides a collection of data
parallel primitives such as scan, sort, and reduce. Thrust is highly
optimized for performance on NVIDIA GPUs by taking advanatge of CUDA
underneath the hood.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ThrustScanWrapper</span></code> function encapsulates the Thrust scan
operation - remember, scan is just another name for prefix sum. It uses
the <code class="docutils literal notranslate"><span class="pre">thrust::exclusize_scan</span></code> function to compute the prefix sum.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ThrustScanWrapper</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numElements</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">thrust</span><span class="o">::</span><span class="n">exclusive_scan</span><span class="p">(</span><span class="n">thrust</span><span class="o">::</span><span class="n">device_ptr</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">),</span>
<span class="w">                           </span><span class="n">thrust</span><span class="o">::</span><span class="n">device_ptr</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">numElements</span><span class="p">),</span>
<span class="w">                           </span><span class="n">thrust</span><span class="o">::</span><span class="n">device_ptr</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">output</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">thrust::exclusize_scan</span></code> function takes three parameters: the
beginning of the input range, the end of the input range, and the
beginning of the output range. It computes the prefix sum of the input
range and stores the result in the output range. The exclusive scan
means that the sum at each position does not include the element at that
position, which aligns with the traditional definition of prefix sums.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">computeIsosurface</span></code> function, after classifying the voxels, a
scan operation is performed on the <code class="docutils literal notranslate"><span class="pre">voxelOccupied</span></code> array. Remember,
this array contains flags indicating whether each voxel is occupied. The
scan operation computes the prefix sum of this array, which results in
the <code class="docutils literal notranslate"><span class="pre">voxelOccupiedScan</span></code> array, which tells us how many occupied voxels
there are up to each position.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ThrustScanWrapper</span><span class="p">(</span><span class="n">d_voxelOccupiedScan</span><span class="p">,</span><span class="w"> </span><span class="n">d_voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">);</span>
</pre></div>
</div>
<p>Thre prefix sum operation is crucial for the compaction step. It allows
us to create a compact array of occupied voxels, eliminating the empty
ones. This compact array is then used in the <code class="docutils literal notranslate"><span class="pre">generateTriangles</span></code>
kernel to efficiently generate the triangles for the isosurface.</p>
</section>
<section id="use-onedpl-thrust-equivalent-in-sycl">
<h3>Use oneDPL (Thrust Equivalent) in SYCL:<a class="headerlink" href="#use-onedpl-thrust-equivalent-in-sycl" title="Link to this heading">#</a></h3>
<p>oneDPL (oneAPI DPC++ Library) serves as the SYCL equivalent to CUDA’s
Thrust library. Both libraries offer high-level abstractions for
parallel algorithms and data structures. In our marching cubes
algorithms, oneDPL can be used to perform the prefix sum (scan)
oeprations, which, we know from above, are crucial for stream compaction
and calculating the number of vertices.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">dpct::device_ext::exclusive_scan</span></code> function is used to perform the
prefix sum operation in SYCL. SYCLomatic helps convert Thrust-based code
to oneDPL-based code, although, just as with our kernels, some manual
adjustments may be required.</p>
<p>For example, the converted prefix sum operation using oneDPL might look
like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;oneapi/dpl/execution&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;oneapi/dpl/algorithm&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">oneDPLScanWrapper</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numElements</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">oneapi</span><span class="o">::</span><span class="n">dpl</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">make_device_policy</span><span class="p">(</span><span class="n">q</span><span class="p">),</span>
<span class="w">    </span><span class="n">oneapi</span><span class="o">::</span><span class="n">dpl</span><span class="o">::</span><span class="n">exclusive_scan</span><span class="p">(</span><span class="n">oneapi</span><span class="o">::</span><span class="n">dpl</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">make_device_policy</span><span class="p">(</span><span class="n">q</span><span class="p">),</span>
<span class="w">                                </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">numElements</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">oneapi::dpl::exclusive_scan</span></code> performs the exclusive
prefix sum operation, similar to Thrust. The
<code class="docutils literal notranslate"><span class="pre">oneapi::dpl::execution::make_device_policy</span></code> function creates a device
policy for the queue, ensuring that the operation is execued on the
appropirate device.</p>
<p>(EDIT THIS SECTION AFTER IMPLEMENTATION)</p>
</section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../91-coc/code-of-conduct.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Code of Conduct</p>
      </div>
    </a>
    <a class="right-next"
       href="../93-electron-density/electron-density.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Electron Density Case Study</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-brief-cuda-reivew">A Brief CUDA Reivew</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#kernels-being-used">Kernels Being Used</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cuda-vs-sycl-implementations">CUDA vs SYCL Implementations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#classify-voxel-kernel-cuda">Classify Voxel Kernel - CUDA:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#classify-voxel-kernel-sycl">Classify Voxel Kernel - SYCL</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compact-voxels-kernel-cuda">Compact Voxels Kernel - CUDA</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compact-voxels-kernel-sycl">Compact Voxels Kernel - SYCL</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generate-triangles-kernel-cuda">Generate Triangles Kernel - CUDA:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generate-triangles-kernel-sycl">Generate Triangles Kernel - SYCL:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#use-of-thrust-library-in-cuda-implementation">Use of Thrust Library in CUDA Implementation:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#use-onedpl-thrust-equivalent-in-sycl">Use oneDPL (Thrust Equivalent) in SYCL:</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Author name not set
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023-Present, George K. Thiruvathukal and Konstantin Läufer.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>