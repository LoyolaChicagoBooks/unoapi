<!DOCTYPE html>

<html :class="{'dark': darkMode === 'dark' || (darkMode === 'system' &amp;&amp; window.matchMedia('(prefers-color-scheme: dark)').matches)}" class="scroll-smooth" data-content_root="../" lang="en" x-data="{ darkMode: localStorage.getItem('darkMode') || localStorage.setItem('darkMode', 'system'), activeSection: '' }" x-init="$watch('darkMode', val =&gt; localStorage.setItem('darkMode', val))">
<head>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta charset="utf-8"/>
<meta content="white" media="(prefers-color-scheme: light)" name="theme-color"/>
<meta content="black" media="(prefers-color-scheme: dark)" name="theme-color"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Marching Cubes: From CUDA to SYCL | UnoAPI: Modern Parallel C++ Programming with SYCL and oneAPI v0.6</title>
<meta content="Marching Cubes: From CUDA to SYCL | UnoAPI: Modern Parallel C++ Programming with SYCL and oneAPI v0.6" property="og:title"/>
<meta content="Marching Cubes: From CUDA to SYCL | UnoAPI: Modern Parallel C++ Programming with SYCL and oneAPI v0.6" name="twitter:title"/>
<link href="../_static/pygments.css?v=03e43079" rel="stylesheet" type="text/css"/>
<link href="../_static/theme.css?v=42baaae4" rel="stylesheet" type="text/css"/>
<link href="../search.html" rel="search" title="Search"/>
<link href="../genindex.html" rel="index" title="Index"/>
<link href="../93-electron-density/electron-density.html" rel="next" title="Electron Density Case Study"/>
<link href="../91-coc/code-of-conduct.html" rel="prev" title="Code of Conduct"/>
<script>
    <!-- Prevent Flash of wrong theme -->
      const userPreference = localStorage.getItem('darkMode');
      let mode;
      if (userPreference === 'dark' || window.matchMedia('(prefers-color-scheme: dark)').matches) {
        mode = 'dark';
        document.documentElement.classList.add('dark');
      } else {
        mode = 'light';
      }
      if (!userPreference) {localStorage.setItem('darkMode', mode)}
    </script>
</head>
<body :class="{ 'overflow-hidden': showSidebar }" class="min-h-screen font-sans antialiased bg-background text-foreground" x-data="{ showSidebar: false, showScrollTop: false }">
<div @click.self="showSidebar = false" class="fixed inset-0 z-50 overflow-hidden bg-background/80 backdrop-blur-sm md:hidden" x-cloak="" x-show="showSidebar"></div><div class="relative flex flex-col min-h-screen" id="page"><a class="absolute top-0 left-0 z-[100] block bg-background p-4 text-xl transition -translate-x-full opacity-0 focus:translate-x-0 focus:opacity-100" href="#content">
      Skip to content
    </a>
<header class="sticky top-0 z-40 w-full border-b shadow-sm border-border supports-backdrop-blur:bg-background/60 bg-background/95 backdrop-blur"><div class="container flex items-center h-14">
<div class="hidden mr-4 md:flex">
<a class="flex items-center mr-6" href="../index.html"><span class="hidden font-bold sm:inline-block text-clip whitespace-nowrap">UnoAPI: Modern Parallel C++ Programming with SYCL and oneAPI v0.6</span>
</a></div><button @click="showSidebar = true" class="inline-flex items-center justify-center h-10 px-0 py-2 mr-2 text-base font-medium transition-colors rounded-md hover:text-accent-foreground hover:bg-transparent md:hidden" type="button">
<svg aria-hidden="true" fill="currentColor" height="24" viewbox="0 96 960 960" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M152.587 825.087q-19.152 0-32.326-13.174t-13.174-32.326q0-19.152 13.174-32.326t32.326-13.174h440q19.152 0 32.326 13.174t13.174 32.326q0 19.152-13.174 32.326t-32.326 13.174h-440Zm0-203.587q-19.152 0-32.326-13.174T107.087 576q0-19.152 13.174-32.326t32.326-13.174h320q19.152 0 32.326 13.174T518.087 576q0 19.152-13.174 32.326T472.587 621.5h-320Zm0-203.587q-19.152 0-32.326-13.174t-13.174-32.326q0-19.152 13.174-32.326t32.326-13.174h440q19.152 0 32.326 13.174t13.174 32.326q0 19.152-13.174 32.326t-32.326 13.174h-440ZM708.913 576l112.174 112.174q12.674 12.674 12.674 31.826t-12.674 31.826Q808.413 764.5 789.261 764.5t-31.826-12.674l-144-144Q600 594.391 600 576t13.435-31.826l144-144q12.674-12.674 31.826-12.674t31.826 12.674q12.674 12.674 12.674 31.826t-12.674 31.826L708.913 576Z"></path>
</svg>
<span class="sr-only">Toggle navigation menu</span>
</button>
<div class="flex items-center justify-between flex-1 space-x-2 sm:space-x-4 md:justify-end">
<div class="flex-1 w-full md:w-auto md:flex-none"><form @keydown.k.window.meta="$refs.search.focus()" action="../search.html" class="relative flex items-center group" id="searchbox" method="get">
<input aria-label="Search the docs" class="inline-flex items-center font-medium transition-colors bg-transparent focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 ring-offset-background border border-input hover:bg-accent focus:bg-accent hover:text-accent-foreground focus:text-accent-foreground hover:placeholder-accent-foreground py-2 px-4 relative h-9 w-full justify-start rounded-[0.5rem] text-sm text-muted-foreground sm:pr-12 md:w-40 lg:w-64" id="search-input" name="q" placeholder="Search ..." type="search" x-ref="search"/>
<kbd class="pointer-events-none absolute right-1.5 top-2 hidden h-5 select-none text-muted-foreground items-center gap-1 rounded border border-border bg-muted px-1.5 font-mono text-[10px] font-medium opacity-100 sm:flex group-hover:bg-accent group-hover:text-accent-foreground">
<span class="text-xs">âŒ˜</span>
    K
  </kbd>
</form>
</div>
<nav class="flex items-center space-x-1">
<button @click="darkMode = darkMode === 'light' ? 'dark' : 'light'" aria-label="Color theme switcher" class="relative inline-flex items-center justify-center px-0 text-sm font-medium transition-colors rounded-md hover:bg-accent hover:text-accent-foreground h-9 w-9" type="button">
<svg class="absolute transition-all scale-100 rotate-0 dark:-rotate-90 dark:scale-0" fill="currentColor" height="24" viewbox="0 96 960 960" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M480 685q45.456 0 77.228-31.772Q589 621.456 589 576q0-45.456-31.772-77.228Q525.456 467 480 467q-45.456 0-77.228 31.772Q371 530.544 371 576q0 45.456 31.772 77.228Q434.544 685 480 685Zm0 91q-83 0-141.5-58.5T280 576q0-83 58.5-141.5T480 376q83 0 141.5 58.5T680 576q0 83-58.5 141.5T480 776ZM80 621.5q-19.152 0-32.326-13.174T34.5 576q0-19.152 13.174-32.326T80 530.5h80q19.152 0 32.326 13.174T205.5 576q0 19.152-13.174 32.326T160 621.5H80Zm720 0q-19.152 0-32.326-13.174T754.5 576q0-19.152 13.174-32.326T800 530.5h80q19.152 0 32.326 13.174T925.5 576q0 19.152-13.174 32.326T880 621.5h-80Zm-320-320q-19.152 0-32.326-13.174T434.5 256v-80q0-19.152 13.174-32.326T480 130.5q19.152 0 32.326 13.174T525.5 176v80q0 19.152-13.174 32.326T480 301.5Zm0 720q-19.152 0-32.326-13.17Q434.5 995.152 434.5 976v-80q0-19.152 13.174-32.326T480 850.5q19.152 0 32.326 13.174T525.5 896v80q0 19.152-13.174 32.33-13.174 13.17-32.326 13.17ZM222.174 382.065l-43-42Q165.5 327.391 166 308.239t13.174-33.065q13.435-13.674 32.587-13.674t32.065 13.674l42.239 43q12.674 13.435 12.555 31.706-.12 18.272-12.555 31.946-12.674 13.674-31.445 13.413-18.772-.261-32.446-13.174Zm494 494.761-42.239-43q-12.674-13.435-12.674-32.087t12.674-31.565Q686.609 756.5 705.38 757q18.772.5 32.446 13.174l43 41.761Q794.5 824.609 794 843.761t-13.174 33.065Q767.391 890.5 748.239 890.5t-32.065-13.674Zm-42-494.761Q660.5 369.391 661 350.62q.5-18.772 13.174-32.446l41.761-43Q728.609 261.5 747.761 262t33.065 13.174q13.674 13.435 13.674 32.587t-13.674 32.065l-43 42.239q-13.435 12.674-31.706 12.555-18.272-.12-31.946-12.555Zm-495 494.761Q165.5 863.391 165.5 844.239t13.674-32.065l43-42.239q13.435-12.674 32.087-12.674t31.565 12.674Q299.5 782.609 299 801.38q-.5 18.772-13.174 32.446l-41.761 43Q231.391 890.5 212.239 890t-33.065-13.174ZM480 576Z"></path>
</svg>
<svg class="absolute transition-all scale-0 rotate-90 dark:rotate-0 dark:scale-100" fill="currentColor" height="24" viewbox="0 96 960 960" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M480 936q-151 0-255.5-104.5T120 576q0-138 90-239.5T440 218q25-3 39 18t-1 44q-17 26-25.5 55t-8.5 61q0 90 63 153t153 63q31 0 61.5-9t54.5-25q21-14 43-1.5t19 39.5q-14 138-117.5 229T480 936Zm0-80q88 0 158-48.5T740 681q-20 5-40 8t-40 3q-123 0-209.5-86.5T364 396q0-20 3-40t8-40q-78 32-126.5 102T200 576q0 116 82 198t198 82Zm-10-270Z"></path>
</svg>
</button>
</nav>
</div>
</div>
</header>
<div class="flex-1"><div class="container flex-1 items-start md:grid md:grid-cols-[220px_minmax(0,1fr)] md:gap-6 lg:grid-cols-[240px_minmax(0,1fr)] lg:gap-10"><aside :aria-hidden="!showSidebar" :class="{ 'translate-x-0': showSidebar }" class="fixed inset-y-0 left-0 md:top-14 z-50 md:z-30 bg-background md:bg-transparent transition-all duration-100 -translate-x-full md:translate-x-0 ml-0 p-6 md:p-0 md:-ml-2 md:h-[calc(100vh-3.5rem)] w-5/6 md:w-full shrink-0 overflow-y-auto border-r border-border md:sticky" id="left-sidebar">
<a class="!justify-start text-sm md:!hidden bg-background" href="../index.html"><span class="font-bold text-clip whitespace-nowrap">UnoAPI: Modern Parallel C++ Programming with SYCL and oneAPI v0.6</span>
</a>
<div class="relative overflow-hidden md:overflow-auto my-4 md:my-0 h-[calc(100vh-8rem)] md:h-auto">
<div class="overflow-y-auto h-full w-full relative pr-6"><nav class="table w-full min-w-full my-6 lg:my-8">
<p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../00-preliminaries/preliminaries.html">About the Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05-parallel/parallel.html">Introduction to Parallel Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10-software-engineering/software-engineering.html">Introduction to Software Engineering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15-modern-cpp/modern-cpp.html">Modern C++ as a Better C (and C++)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18-dpcpp/dpcpp.html">Data-Parallel C++ with oneAPI/SYCL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20-quant-finance/qfi.html">Quantitative Finance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../30-performance/performance.html">Performance Essentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../80-running/running.html">Compiling and Running oneAPI programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../90-contributions/contributions.html">Contribution Guildelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../91-coc/code-of-conduct.html">Code of Conduct</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Marching Cubes: From CUDA to SYCL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../93-electron-density/electron-density.html">Electron Density Case Study</a></li>
<li class="toctree-l1"><a class="reference internal" href="../99-chapter-template/chapter-title.html">Chapter Title</a></li>
</ul>
</nav>
</div>
</div>
<button @click="showSidebar = false" class="absolute md:hidden right-4 top-4 rounded-sm opacity-70 transition-opacity hover:opacity-100" type="button">
<svg class="h-4 w-4" fill="currentColor" height="24" stroke="none" viewbox="0 96 960 960" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M480 632 284 828q-11 11-28 11t-28-11q-11-11-11-28t11-28l196-196-196-196q-11-11-11-28t11-28q11-11 28-11t28 11l196 196 196-196q11-11 28-11t28 11q11 11 11 28t-11 28L536 576l196 196q11 11 11 28t-11 28q-11 11-28 11t-28-11L480 632Z"></path>
</svg>
</button>
</aside>
<main class="relative py-6 lg:gap-10 lg:py-8 xl:grid xl:grid-cols-[1fr_300px]">
<div class="w-full min-w-0 mx-auto">
<nav aria-label="breadcrumbs" class="flex items-center mb-4 space-x-1 text-sm text-muted-foreground">
<a class="overflow-hidden text-ellipsis whitespace-nowrap hover:text-foreground" href="../index.html">
<span class="hidden md:inline">UnoAPI: Modern Parallel C++ Programming with SYCL and oneAPI v0.6</span>
<svg aria-label="Home" class="md:hidden" fill="currentColor" height="18" stroke="none" viewbox="0 96 960 960" width="18" xmlns="http://www.w3.org/2000/svg">
<path d="M240 856h120V616h240v240h120V496L480 316 240 496v360Zm-80 80V456l320-240 320 240v480H520V696h-80v240H160Zm320-350Z"></path>
</svg>
</a>
<div class="mr-1">/</div><span aria-current="page" class="font-medium text-foreground overflow-hidden text-ellipsis whitespace-nowrap">Marching Cubes: From CUDA to SYCL</span>
</nav>
<div id="content" role="main">
<section id="marching-cubes-from-cuda-to-sycl">
<h1>Marching Cubes: From CUDA to SYCL<a class="headerlink" href="#marching-cubes-from-cuda-to-sycl" title="Link to this heading">Â¶</a></h1>
<p>This Gist provides a walkthrough of the marching cubes algorithm
implemented in CUDA. The code can be found in its entirety here (enter
hyperlink later). We start by briefly reviewing how parallelization
works in CUDA. We then take a look at some of the key kernels being used
in a CUDA implementation of the marching cubes algorithm. Those CUDA
kernels are then put through the SYCLomatic tool, a tool developed to
aid in the porting of code from other languages to SYCL. We then clean
up the output of the SYCLomatic tool into a final working version of
SYCL kernels.</p>
<section id="a-brief-cuda-reivew">
<h2>A Brief CUDA Reivew<a class="headerlink" href="#a-brief-cuda-reivew" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#a-brief-cuda-reivew'">Â¶</a></h2>
<p>CUDA enables parallelization by allowing the programmer to define a
kernel that is executed by a large numberof threads concurrently. Each
thread processes a small portion of the data, and the collective work of
all threads achieves the overall computation. The combination of thread
and block indices allows each thread to work on a unique subset of the
data, thus ensuring that the entire dataset is processed in parallel. â€¦
more stuff about how cuda works</p>
</section>
<section id="kernels-being-used">
<h2>Kernels Being Used<a class="headerlink" href="#kernels-being-used" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#kernels-being-used'">Â¶</a></h2>
<p>List them here</p>
</section>
<section id="cuda-vs-sycl-implementations">
<h2>CUDA vs SYCL Implementations<a class="headerlink" href="#cuda-vs-sycl-implementations" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#cuda-vs-sycl-implementations'">Â¶</a></h2>
<section id="classify-voxel-kernel-cuda">
<h3>Classify Voxel Kernel - CUDA:<a class="headerlink" href="#classify-voxel-kernel-cuda" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#classify-voxel-kernel-cuda'">Â¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">classifyVoxel</span></code> kernel classifies each voxel in a 3D grid based on
the number of vertices it will generate. Letâ€™s breakdown how it works:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">classifyVoxel</span><span class="p">(</span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelVerts</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">uchar</span><span class="w"> </span><span class="o">*</span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSize</span><span class="p">,</span>
</span><span id="line-2"><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">,</span><span class="w"> </span><span class="n">float3</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">numVertsTex</span><span class="p">,</span><span class="w"> </span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">volumeTex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-3"><span class="w">    </span><span class="c1">// Calculate the unique index for this thread within the entire grid</span>
</span><span id="line-4"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span id="line-5"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span id="line-6">
</span><span id="line-7"><span class="w">    </span><span class="c1">// Compute the position in the 3D grid</span>
</span><span id="line-8"><span class="w">    </span><span class="n">uint3</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calcGridPos</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">);</span>
</span><span id="line-9">
</span><span id="line-10"><span class="w">    </span><span class="c1">//Read field values at the 8 neighboring grid vertices</span>
</span><span id="line-11"><span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span><span id="line-12"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="p">,</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-13"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-14"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-15"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-16"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-17"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-18"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-19"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-20">
</span><span id="line-21"><span class="w">    </span><span class="c1">// Calculate a falg indicating if each vertex is inside of outside the isosurface</span>
</span><span id="line-22"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">);</span>
</span><span id="line-23"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
</span><span id="line-24"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
</span><span id="line-25"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
</span><span id="line-26"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
</span><span id="line-27"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
</span><span id="line-28"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>
</span><span id="line-29"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span>
</span><span id="line-30">
</span><span id="line-31"><span class="w">    </span><span class="c1">//Read the number of vertices from the texture</span>
</span><span id="line-32"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">numVerts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tex1Dfetch</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numVertsTex</span><span class="p">,</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">);</span>
</span><span id="line-33">
</span><span id="line-34"><span class="w">    </span><span class="c1">// If the voxel index is within bounds, store the number of vertices and occupancy</span>
</span><span id="line-35"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-36"><span class="w">        </span><span class="n">voxelVerts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numVerts</span><span class="p">;</span>
</span><span id="line-37"><span class="w">        </span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">numVerts</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</span><span id="line-38"><span class="w">    </span><span class="p">}</span>
</span><span id="line-39">
</span><span id="line-40"><span class="w">    </span><span class="c1">// Print the results to verify the SYCL equivalent kernel produces the same results</span>
</span><span id="line-41"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-42"><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"Voxel %u: numVerts=%u, occupied=%u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">numVerts</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span id="line-43"><span class="w">    </span><span class="p">}</span>
</span><span id="line-44"><span class="p">}</span>
</span></code></pre></div>
</div>
<p>The kernel starts by assigning each thread a uinque index <code class="docutils literal notranslate"><span class="pre">i</span></code> by
calculating <code class="docutils literal notranslate"><span class="pre">blockId</span></code> and multiplying it by the number of threads per
block. This index <code class="docutils literal notranslate"><span class="pre">i</span></code> corresponds to a specific voxel in the grid.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span id="line-2"><span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></code></pre></div>
</div>
<p>The 1D index <code class="docutils literal notranslate"><span class="pre">i</span></code> is then converted to a 3D grid position <code class="docutils literal notranslate"><span class="pre">gridPos</span></code>
by using the <code class="docutils literal notranslate"><span class="pre">calcGridPos</span></code> function. This is needed for locating the
voxelâ€™s position in the 3D volume.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="n">uint3</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calcGridPos</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">);</span>
</span></code></pre></div>
</div>
<p>The field values at the eight corners of the voxel are then sampled
using the <code class="docutils literal notranslate"><span class="pre">sampleVolume</span></code> function, which accesses the volume data
through the texture object <code class="docutils literal notranslate"><span class="pre">volumeTex</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="kt">float</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span><span id="line-2"><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="p">,</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-3"><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-4"><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-5"><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-6"><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-7"><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-8"><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-9"><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span></code></pre></div>
</div>
<p>Each cornerâ€™s field value then needs to be compared to the <code class="docutils literal notranslate"><span class="pre">isoValue</span></code>.
If if field value is less than the <code class="docutils literal notranslate"><span class="pre">isoValue</span></code>, the corresponding bit
in <code class="docutils literal notranslate"><span class="pre">cubeindex</span></code> is set. The <code class="docutils literal notranslate"><span class="pre">cubeindex</span></code> thus forms a unique
identifier representing the voxelâ€™s classification.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="n">uint</span><span class="w"> </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">);</span>
</span><span id="line-2"><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
</span><span id="line-3"><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
</span><span id="line-4"><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
</span><span id="line-5"><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
</span><span id="line-6"><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
</span><span id="line-7"><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>
</span><span id="line-8"><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span>
</span></code></pre></div>
</div>
<p>The number of vertices for the given <code class="docutils literal notranslate"><span class="pre">cubeindex</span></code> is then fetched from
the texure <code class="docutils literal notranslate"><span class="pre">numVertsTex</span></code>. This lookup is essential for determining how
many vertices the voxel will generate.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="n">uint</span><span class="w"> </span><span class="n">numVerts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tex1Dfetch</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numVertsTex</span><span class="p">,</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">);</span>
</span></code></pre></div>
</div>
<p>Lastly, the voxel index <code class="docutils literal notranslate"><span class="pre">i</span></code> is checked to see if it within bounds. If
it is, the numberof vertices and occupancy status are stored in
<code class="docutils literal notranslate"><span class="pre">voxelVerts</span></code> and <code class="docutils literal notranslate"><span class="pre">voxelOccupied</span></code> arrays, respectively.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-2"><span class="w">    </span><span class="n">voxelVerts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numVerts</span><span class="p">;</span>
</span><span id="line-3"><span class="w">    </span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">numVerts</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</span></code></pre></div>
</div>
<p>We also print the voxel index, number of vertices, and occupancy status,
as we will check this output against a SYCL equivalent kernel later.</p>
</section>
<section id="classify-voxel-kernel-sycl">
<h3>Classify Voxel Kernel - SYCL<a class="headerlink" href="#classify-voxel-kernel-sycl" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#classify-voxel-kernel-sycl'">Â¶</a></h3>
<p>Below we can see the output of SYCLomatic when converting the above CUDA
kernel to SYCL. While the tool gets the programmer very far in the
porting process, you will see that it is not 100% porting solution, and
some portions of the code need to be manually addressed.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="kt">void</span><span class="w"> </span><span class="nf">classifyVoxel</span><span class="p">(</span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelVerts</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">uchar</span><span class="w"> </span><span class="o">*</span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSize</span><span class="p">,</span>
</span><span id="line-2"><span class="w">                   </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">,</span>
</span><span id="line-3"><span class="w">                   </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">isoValue</span><span class="p">,</span>
</span><span id="line-4"><span class="w">                   </span><span class="n">dpct</span><span class="o">::</span><span class="n">image_accessor_ext</span><span class="o">&lt;</span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">numVertsTex</span><span class="p">,</span>
</span><span id="line-5"><span class="w">                   </span><span class="n">dpct</span><span class="o">::</span><span class="n">image_accessor_ext</span><span class="o">&lt;</span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">volumeTex</span><span class="p">,</span>
</span><span id="line-6"><span class="w">                   </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item_ct1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-7">
</span><span id="line-8"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span id="line-9">
</span><span id="line-10"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_id</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span id="line-11">
</span><span id="line-12"><span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calcGridPos</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">);</span>
</span><span id="line-13">
</span><span id="line-14"><span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span><span id="line-15"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="p">,</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-16"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-17"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-18"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-19"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-20"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-21"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-22"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-23">
</span><span id="line-24"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">;</span>
</span><span id="line-25"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">);</span>
</span><span id="line-26"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
</span><span id="line-27"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
</span><span id="line-28"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
</span><span id="line-29"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
</span><span id="line-30"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
</span><span id="line-31"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>
</span><span id="line-32"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span>
</span><span id="line-33">
</span><span id="line-34"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">numVerts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tex1Dfetch</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numVertsTex</span><span class="p">,</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">);</span>
</span><span id="line-35">
</span><span id="line-36"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-37"><span class="w">        </span><span class="n">voxelVerts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numVerts</span><span class="p">;</span>
</span><span id="line-38"><span class="w">        </span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">numVerts</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</span><span id="line-39"><span class="w">    </span><span class="p">}</span>
</span><span id="line-40">
</span><span id="line-41"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-42"><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"Voxel %u: numVerts=%u, occupied=%u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">numVerts</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span id="line-43"><span class="w">    </span><span class="p">}</span>
</span><span id="line-44"><span class="p">}</span>
</span><span id="line-45">
</span><span id="line-46"><span class="k">extern</span><span class="w"> </span><span class="s">"C"</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">launch_classifyVoxel</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelVerts</span><span class="p">,</span>
</span><span id="line-47"><span class="w">                                     </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">uchar</span><span class="w"> </span><span class="o">*</span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSize</span><span class="p">,</span>
</span><span id="line-48"><span class="w">                                     </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">,</span>
</span><span id="line-49"><span class="w">                                     </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-50">
</span><span id="line-51"><span class="w">    </span><span class="n">dpct</span><span class="o">::</span><span class="n">get_in_order_queue</span><span class="p">().</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cgh</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-52"><span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">numVertsTex_acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">dpct</span><span class="o">::</span><span class="n">image_wrapper</span><span class="o">&lt;</span>
</span><span id="line-53"><span class="w">            </span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">numVertsTex</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">get_access</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>
</span><span id="line-54"><span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">volumeTex_acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">dpct</span><span class="o">::</span><span class="n">image_wrapper</span><span class="o">&lt;</span>
</span><span id="line-55"><span class="w">            </span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">get_access</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>
</span><span id="line-56">
</span><span id="line-57"><span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">numVertsTex_smpl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numVertsTex</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">get_sampler</span><span class="p">();</span>
</span><span id="line-58"><span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">volumeTex_smplt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">volumeTex</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">get_sampler</span><span class="p">();</span>
</span><span id="line-59">
</span><span id="line-60"><span class="w">        </span><span class="n">cgh</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-61"><span class="w">            </span><span class="n">classifyVoxel</span><span class="p">(</span>
</span><span id="line-62"><span class="w">                </span><span class="n">voxelVerts</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridSize</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span>
</span><span id="line-63"><span class="w">                </span><span class="n">gridSizeMask</span><span class="p">,</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">,</span><span class="w"> </span><span class="n">isoValue</span><span class="p">,</span>
</span><span id="line-64"><span class="w">                </span><span class="n">dpct</span><span class="o">::</span><span class="n">image_accessor_ext</span><span class="o">&lt;</span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span>
</span><span id="line-65"><span class="w">                    </span><span class="n">numVertsTex_smpl</span><span class="p">,</span><span class="w"> </span><span class="n">numVertsTex_acc</span><span class="p">),</span>
</span><span id="line-66"><span class="w">                </span><span class="n">dpct</span><span class="o">::</span><span class="n">image_accessor_ext</span><span class="o">&lt;</span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span>
</span><span id="line-67"><span class="w">                    </span><span class="n">volumeTex_smpl</span><span class="p">,</span><span class="w"> </span><span class="n">volumeTex_acc</span><span class="p">),</span>
</span><span id="line-68"><span class="w">                </span><span class="n">item_ct1</span><span class="p">);</span>
</span><span id="line-69"><span class="w">        </span><span class="p">});</span>
</span><span id="line-70"><span class="w">    </span><span class="p">});</span>
</span><span id="line-71">
</span><span id="line-72"><span class="w">    </span><span class="n">getLastCudaError</span><span class="p">(</span><span class="s">"classifyVoxel failed"</span><span class="p">);</span>
</span><span id="line-73"><span class="p">}</span>
</span></code></pre></div>
</div>
<p><strong>Thread and Block Indices:</strong></p>
<p>SYCLomatic uses SYCLâ€™s <code class="docutils literal notranslate"><span class="pre">nd_iem</span></code> to handle thread and block indices,
analogous to CUDAâ€™s <code class="docutils literal notranslate"><span class="pre">blockIdx</span></code>, <code class="docutils literal notranslate"><span class="pre">threadIdx</span></code>, and <code class="docutils literal notranslate"><span class="pre">blockDim</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct2</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span id="line-2"><span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_id</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></code></pre></div>
</div>
<p><strong>Grid Position Calculation:</strong></p>
<p>The function <code class="docutils literal notranslate"><span class="pre">calcGridPos</span></code> remains unchanged and works the same way as
in CUDA.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calcGridPos</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">);</span>
</span></code></pre></div>
</div>
<p><strong>Field Value Sampling:</strong></p>
<p>The texture access functions are replaces by SYCL equivalents.
<code class="docutils literal notranslate"><span class="pre">sampleVolume</span></code> is called the same way as in CUDA.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="kt">float</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span><span id="line-2"><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="p">,</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-3"><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVolume</span><span class="p">(</span><span class="n">volumeTex</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">gridSize</span><span class="p">);</span>
</span><span id="line-4"><span class="p">...</span>
</span></code></pre></div>
</div>
<p><strong>Isosurface Classification and Number of Vertices Lookup</strong></p>
<p>The operations for comparing field values and fetching the number of
vertices are similar in SYCL.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="n">uint</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">;</span>
</span><span id="line-2"><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">);</span>
</span><span id="line-3"><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
</span><span id="line-4"><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
</span><span id="line-5"><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
</span><span id="line-6"><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
</span><span id="line-7"><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
</span><span id="line-8"><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>
</span><span id="line-9"><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span>
</span><span id="line-10"><span class="n">uint</span><span class="w"> </span><span class="n">numVerts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tex1Dfetch</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numVertsTex</span><span class="p">,</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">);</span>
</span></code></pre></div>
</div>
<p>The code for storing the results and printing remains the same.</p>
</section>
<section id="compact-voxels-kernel-cuda">
<h3>Compact Voxels Kernel - CUDA<a class="headerlink" href="#compact-voxels-kernel-cuda" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#compact-voxels-kernel-cuda'">Â¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">compactVoxels</span></code> kernel is crucial for compacting the voxel arrary
by eliminating empty voxels and creating a contiguous array of active
voxels.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">compactVoxels</span><span class="p">(</span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">compactedVoxelArray</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupiedScan</span><span class="p">,</span>
</span><span id="line-2"><span class="w">                                                                              </span><span class="n">uint</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-3"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span id="line-4"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span id="line-5">
</span><span id="line-6"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-7"><span class="w">        </span><span class="n">compactedVoxelArray</span><span class="p">[</span><span class="n">voxelOccupiedScan</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
</span><span id="line-8"><span class="w">    </span><span class="p">}</span>
</span><span id="line-9">
</span><span id="line-10"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-11"><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"Compact voxel %u: compactedIndex=%u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupiedScan</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span id="line-12"><span class="w">    </span><span class="p">}</span>
</span><span id="line-13"><span class="p">}</span>
</span></code></pre></div>
</div>
<p><strong>Thread and Block Indices</strong></p>
<p>CUDA organizes threads into blocks and blocks into grids. Each thread
has a unique index within its block, and each block has a unique index
within the grid.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span id="line-2"><span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></code></pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">blockIdx.y</span></code> and <code class="docutils literal notranslate"><span class="pre">blockIdx.x</span></code> are the block indices in the y and
x dimensions of the grid.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gridDim.x</span></code> is the number of blocks in the x dimension.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">blockDim.x</span></code> is the number of threads in a block.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">threadIdx.x</span></code> is the thread index within the block.</p></li>
</ul>
<p>The global thread index <code class="docutils literal notranslate"><span class="pre">i</span></code> is computed to uniquely identify each
threadâ€™s work item.</p>
<p><strong>Compaction Condition:</strong> - Each thread checks if the voxel at index
<code class="docutils literal notranslate"><span class="pre">i</span></code> is occupied and if <code class="docutils literal notranslate"><span class="pre">i</span></code> is within our bounds.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
</span></code></pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">voxelOccupied[i]</span></code> is a boolean array indicating whether the voxel
at index <code class="docutils literal notranslate"><span class="pre">i</span></code> is occupied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numVoxels</span></code> is the total number of voxels.</p></li>
</ul>
<p><strong>Compaction Operation</strong> If the voxel is occupied, the kernel writes the
voxelâ€™s index to the <code class="docutils literal notranslate"><span class="pre">compactedVoxelArray</span></code> at the position specified
by <code class="docutils literal notranslate"><span class="pre">voxelOccupiedScan[i]</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="n">compactedVoxelArray</span><span class="p">[</span><span class="n">voxelOccupiedScan</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
</span></code></pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">voxelOccupiedScan</span></code> is an array that contains the result of the
prefix sum operation on <code class="docutils literal notranslate"><span class="pre">voxelOccupied</span></code>. It provides the position
in the compacted array for each occupied voxel.</p></li>
</ul>
<p>We again have the kernel print the voxel index and its new compacted
index to check this against the SYCL version.</p>
</section>
<section id="compact-voxels-kernel-sycl">
<h3>Compact Voxels Kernel - SYCL<a class="headerlink" href="#compact-voxels-kernel-sycl" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#compact-voxels-kernel-sycl'">Â¶</a></h3>
<p>This is the output of the above CUDA kernel when put through SYCLomatic.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="kt">void</span><span class="w"> </span><span class="nf">compactVoxels</span><span class="p">(</span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">compactedVoxelArray</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupiedScan</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">,</span>
</span><span id="line-2"><span class="w">                   </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item_ct1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-3">
</span><span id="line-4"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span id="line-5"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_id</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span id="line-6">
</span><span id="line-7"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-8"><span class="w">        </span><span class="n">compactedVoxelArray</span><span class="p">[</span><span class="n">voxelOccupiedScan</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
</span><span id="line-9"><span class="w">    </span><span class="p">}</span>
</span><span id="line-10">
</span><span id="line-11"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-12"><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"Compact voxel %u: compactedIndex=%u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupiedScan</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span id="line-13"><span class="w">    </span><span class="p">}</span>
</span><span id="line-14"><span class="p">}</span>
</span><span id="line-15">
</span><span id="line-16"><span class="k">extern</span><span class="w"> </span><span class="s">"C"</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">launch_compactVoxels</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">compactedVoxelArray</span><span class="p">,</span>
</span><span id="line-17"><span class="w">                                     </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupiedScan</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-18">
</span><span id="line-19"><span class="w">    </span><span class="n">dpct</span><span class="o">::</span><span class="n">get_in_order_queue</span><span class="p">().</span><span class="n">parllel_for</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">),</span>
</span><span id="line-20"><span class="w">                                           </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-21"><span class="w">        </span><span class="n">compactVoxels</span><span class="p">(</span><span class="n">compactedVoxelArray</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupiedScan</span><span class="p">,</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">,</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">);</span>
</span><span id="line-22"><span class="w">    </span><span class="p">});</span>
</span><span id="line-23">
</span><span id="line-24"><span class="w">    </span><span class="n">getLastCudaError</span><span class="p">(</span><span class="s">"compactVoxels failed"</span><span class="p">);</span>
</span><span id="line-25"><span class="p">}</span>
</span></code></pre></div>
</div>
<p><strong>Thread and Block Indices</strong></p>
<p>We again see that SYCLomatic uses SYCLâ€™s <code class="docutils literal notranslate"><span class="pre">nd_item</span></code> to handle thread
and block indices, just as CUDA would use <code class="docutils literal notranslate"><span class="pre">blockIdx</span></code>, <code class="docutils literal notranslate"><span class="pre">threadIdx</span></code>,
and <code class="docutils literal notranslate"><span class="pre">blockDim</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span id="line-2"><span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_id</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></code></pre></div>
</div>
<p><strong>Compaction Condition and Operation</strong></p>
<p>The compaction condition and operation are directly translated to SYCL,
maintaining the same logic as in CUDA.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">voxelOccupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-2"><span class="w">    </span><span class="n">compactedVoxelArray</span><span class="p">[</span><span class="n">voxelOccupiedScan</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
</span><span id="line-3"><span class="p">}</span>
</span></code></pre></div>
</div>
<p><strong>Kernel Launch</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">launch_compactVoxels</span></code> function in SYCL uses
<code class="docutils literal notranslate"><span class="pre">dpct::get_in_order_queue().parallel_for</span></code> to submit the kernel for
execution (talk more about the extern C stuffâ€¦)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="k">extern</span><span class="w"> </span><span class="s">"C"</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">launch_compactVoxels</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">compactedVoxelArray</span><span class="p">,</span>
</span><span id="line-2"><span class="w">                                     </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">voxelOccupiedScan</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-3">
</span><span id="line-4"><span class="w">    </span><span class="n">dpct</span><span class="o">::</span><span class="n">get_in_order_queue</span><span class="p">().</span><span class="n">parallel_for</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">),</span>
</span><span id="line-5"><span class="w">                                            </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-6"><span class="w">        </span><span class="n">compactVoxels</span><span class="p">(</span><span class="n">compactedVoxelArray</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">voxelOccupiedScan</span><span class="p">,</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">,</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">);</span>
</span><span id="line-7"><span class="w">    </span><span class="p">});</span>
</span><span id="line-8">
</span><span id="line-9"><span class="w">    </span><span class="n">getLastCudaError</span><span class="p">(</span><span class="s">"compactVoxels failed"</span><span class="p">);</span>
</span><span id="line-10"><span class="p">}</span>
</span></code></pre></div>
</div>
</section>
<section id="generate-triangles-kernel-cuda">
<h3>Generate Triangles Kernel - CUDA:<a class="headerlink" href="#generate-triangles-kernel-cuda" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#generate-triangles-kernel-cuda'">Â¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">generateTriangles</span></code> kernel is the heart of the marching cubes
algorithm, responsible for generating the actual triangles that form the
isosurface. This kernel takes the compacted voxel array and, for each
active voxel, generates the necessary vertices and normals for the
triangles.</p>
<p>The kernel starts by assigning each thread a unique index <code class="docutils literal notranslate"><span class="pre">i</span></code> by
calculating <code class="docutils literal notranslate"><span class="pre">blockId</span></code> and multiplying it by the number of threads per
block. This index <code class="docutils literal notranslate"><span class="pre">i</span></code> corresponds to a specific voxel in the compacted
voxel array.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">generateTriangles</span><span class="p">(</span><span class="n">float4</span><span class="w"> </span><span class="o">*</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="o">*</span><span class="n">norm</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">compactedVoxelArray</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">numVertsScanned</span><span class="p">,</span>
</span><span id="line-2"><span class="w">                                  </span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSize</span><span class="p">,</span><span class="w"> </span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">,</span><span class="w"> </span><span class="n">float3</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">,</span>
</span><span id="line-3"><span class="w">                                  </span><span class="kt">float</span><span class="w"> </span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">activeVoxels</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">maxVerts</span><span class="p">,</span><span class="w"> </span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">triTex</span><span class="p">,</span>
</span><span id="line-4"><span class="w">                                  </span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">numvertsTex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-5">
</span><span id="line-6"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span id="line-7"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__mul24</span><span class="p">(</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span id="line-8">
</span><span id="line-9"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">activeVoxels</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-10"><span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">activeVoxels</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</span><span id="line-11"><span class="w">    </span><span class="p">}</span>
</span><span id="line-12">
</span><span id="line-13"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">voxel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compactedVoxelArray</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span id="line-14"><span class="w">    </span><span class="n">uint3</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calcGridPos</span><span class="p">(</span><span class="n">voxel</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">);</span>
</span><span id="line-15">
</span><span id="line-16"><span class="w">    </span><span class="n">float3</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
</span><span id="line-17"><span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.0f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">gridPos</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span><span id="line-18"><span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.0f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">gridPos</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span id="line-19"><span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.0f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">gridPos</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span><span id="line-20">
</span><span id="line-21"><span class="w">    </span><span class="n">float3</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span><span id="line-22"><span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
</span><span id="line-23"><span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_float3</span><span class="p">(</span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</span><span id="line-24"><span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_float3</span><span class="p">(</span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</span><span id="line-25"><span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</span><span id="line-26"><span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span><span id="line-27"><span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_float3</span><span class="p">(</span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span><span id="line-28"><span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_float3</span><span class="p">(</span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span><span id="line-29"><span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">make_float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span><span id="line-30">
</span><span id="line-31"><span class="w">    </span><span class="n">float4</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span><span id="line-32"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span id="line-33"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span><span id="line-34"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span><span id="line-35"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
</span><span id="line-36"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
</span><span id="line-37"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
</span><span id="line-38"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
</span><span id="line-39"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
</span><span id="line-40">
</span><span id="line-41"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">;</span>
</span><span id="line-42"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">);</span>
</span><span id="line-43"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
</span><span id="line-44"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
</span><span id="line-45"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
</span><span id="line-46"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
</span><span id="line-47"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
</span><span id="line-48"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>
</span><span id="line-49"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span>
</span><span id="line-50">
</span><span id="line-51"><span class="w">    </span><span class="n">float3</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
</span><span id="line-52"><span class="w">    </span><span class="n">float3</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
</span><span id="line-53">
</span><span id="line-54"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span id="line-55"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span><span id="line-56"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span><span id="line-57"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
</span><span id="line-58">
</span><span id="line-59"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
</span><span id="line-60"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
</span><span id="line-61"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
</span><span id="line-62"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
</span><span id="line-63">
</span><span id="line-64"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
</span><span id="line-65"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">9</span><span class="p">]);</span>
</span><span id="line-66"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>
</span><span id="line-67"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">11</span><span class="p">]);</span>
</span><span id="line-68">
</span><span id="line-69"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">numVerts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tex1Dfetch</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numVertsTex</span><span class="p">,</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">);</span>
</span><span id="line-70">
</span><span id="line-71"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVerts</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-72"><span class="w">        </span><span class="n">uint</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tex1Dfetch</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">triTex</span><span class="p">,</span><span class="w"> </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
</span><span id="line-73"><span class="w">        </span><span class="n">uint</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numVertsScanned</span><span class="p">[</span><span class="n">voxel</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
</span><span id="line-74">
</span><span id="line-75"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maxVerts</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-76"><span class="w">            </span><span class="n">pos</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_float4</span><span class="p">(</span><span class="n">vertlist</span><span class="p">[</span><span class="n">edge</span><span class="p">],</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>
</span><span id="line-77"><span class="w">            </span><span class="n">norm</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_float4</span><span class="p">(</span><span class="n">normlist</span><span class="p">[</span><span class="n">edge</span><span class="p">],</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
</span><span id="line-78"><span class="w">        </span><span class="p">}</span>
</span><span id="line-79"><span class="w">    </span><span class="p">}</span>
</span><span id="line-80"><span class="p">}</span>
</span></code></pre></div>
</div>
<p>The first step in the kernel is to calculate the unique index for the
thread within the entire grid. This index <code class="docutils literal notranslate"><span class="pre">i</span></code> is used to fetch the
voxel index from the compacted voxel array.</p>
<p>The kernel then computes the 3D grid position of the voxel using the
<code class="docutils literal notranslate"><span class="pre">calcGridPos</span></code> function. This 3D position is necessary to determine the
coordinates of the voxelâ€™s corners in the volume.</p>
<p>The positions of the voxelâ€™s eight corners are calculated relative to
the 3D grid position and the voxel size. These positions are stored in
the <code class="docutils literal notranslate"><span class="pre">v</span></code> array.</p>
<p>Next, the field values at these eight corners are evaluated using the
<code class="docutils literal notranslate"><span class="pre">fieldFunc4</span></code> function, which returns both the field value and its
gradient at each corner. These values are stored in the <code class="docutils literal notranslate"><span class="pre">field</span></code> array.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">cubeindex</span></code> is then calcualted by comparing each field value to
the isovalue. The <code class="docutils literal notranslate"><span class="pre">cubeindex</span></code> is a unique identifier representing the
classification of the voxel based on the isovalue.</p>
<p>The vertices where the isosurface intersects the cube edges are computed
using the <code class="docutils literal notranslate"><span class="pre">vertexInterp2</span></code> function. This function interpolates the
positions and normals of the vertices along the edges of the cube. These
vertices are stored in the <code class="docutils literal notranslate"><span class="pre">vertlist</span></code> and <code class="docutils literal notranslate"><span class="pre">normlist</span></code> arrays,
respectively.</p>
<p>The number of vertiecs for the given <code class="docutils literal notranslate"><span class="pre">cubeindex</span></code> is fetched from the
<code class="docutils literal notranslate"><span class="pre">numVertsTex</span></code> texture. This value indicates how many verties are
needed to form the triangles for this voxel.</p>
<p>Finally, the kerne. iterates over the required number of vertices,
fetching the corresponding edge indices from the <code class="docutils literal notranslate"><span class="pre">triTex</span></code> texture. It
then writes the positions and normals of these verties to the output
arrays <code class="docutils literal notranslate"><span class="pre">pos</span></code> and <code class="docutils literal notranslate"><span class="pre">norm</span></code>.</p>
</section>
<section id="generate-triangles-kernel-sycl">
<h3>Generate Triangles Kernel - SYCL:<a class="headerlink" href="#generate-triangles-kernel-sycl" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#generate-triangles-kernel-sycl'">Â¶</a></h3>
<p>When we use SYCLomatic to convert the above into SYCL, the
<code class="docutils literal notranslate"><span class="pre">generateTriangles</span></code> kernel retains the same logic but adapts to the
SYCL programming model. Here is the output:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="kt">void</span><span class="w"> </span><span class="nf">generateTriangles</span><span class="p">(</span><span class="n">float4</span><span class="w"> </span><span class="o">*</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="o">*</span><span class="n">norm</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">compactedVoxelArray</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">numVertsScanned</span><span class="p">,</span>
</span><span id="line-2"><span class="w">                       </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSize</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">,</span>
</span><span id="line-3"><span class="w">                       </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">activeVoxels</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">maxVerts</span><span class="p">,</span>
</span><span id="line-4"><span class="w">                       </span><span class="n">dpct</span><span class="o">::</span><span class="n">image_accessor_ext</span><span class="o">&lt;</span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">triTex</span><span class="p">,</span>
</span><span id="line-5"><span class="w">                       </span><span class="n">dpct</span><span class="o">::</span><span class="n">image_accessor_ext</span><span class="o">&lt;</span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">numVertsTex</span><span class="p">,</span>
</span><span id="line-6"><span class="w">                       </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item_ct1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-7">
</span><span id="line-8"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">blockId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_group</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span id="line-9"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">mul24</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">blockId</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">item_ct1</span><span class="p">.</span><span class="n">get_local_range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item_Ct1</span><span class="p">.</span><span class="n">get_local_id</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span id="line-10">
</span><span id="line-11"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">activeVoxels</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-12"><span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">activeVoxels</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</span><span id="line-13"><span class="w">    </span><span class="p">}</span>
</span><span id="line-14">
</span><span id="line-15"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">voxel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compactedVoxelArray</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span id="line-16"><span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calcGridPos</span><span class="p">(</span><span class="n">voxel</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">);</span>
</span><span id="line-17">
</span><span id="line-18"><span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
</span><span id="line-19"><span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.0f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">gridPos</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span><span id="line-20"><span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.0f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">gridPos</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span id="line-21"><span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.0f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">gridPos</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span><span id="line-22">
</span><span id="line-23"><span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span><span id="line-24"><span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
</span><span id="line-25"><span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="p">(</span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</span><span id="line-26"><span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="p">(</span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</span><span id="line-27"><span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</span><span id="line-28"><span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span><span id="line-29"><span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="p">(</span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span><span id="line-30"><span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="p">(</span><span class="n">voxelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span><span id="line-31"><span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span><span id="line-32">
</span><span id="line-33"><span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">float4</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span><span id="line-34"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span id="line-35"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span><span id="line-36"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span><span id="line-37"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
</span><span id="line-38"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
</span><span id="line-39"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
</span><span id="line-40"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
</span><span id="line-41"><span class="w">    </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fieldFunc4</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
</span><span id="line-42">
</span><span id="line-43"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">;</span>
</span><span id="line-44"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">);</span>
</span><span id="line-45"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
</span><span id="line-46"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
</span><span id="line-47"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
</span><span id="line-48"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
</span><span id="line-49"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
</span><span id="line-50"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>
</span><span id="line-51"><span class="w">    </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">isoValue</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span>
</span><span id="line-52">
</span><span id="line-53"><span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
</span><span id="line-54"><span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
</span><span id="line-55">
</span><span id="line-56"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span id="line-57"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span><span id="line-58"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span><span id="line-59"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
</span><span id="line-60">
</span><span id="line-61"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
</span><span id="line-62"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
</span><span id="line-63"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
</span><span id="line-64"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
</span><span id="line-65">
</span><span id="line-66"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
</span><span id="line-67"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">9</span><span class="p">]);</span>
</span><span id="line-68"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>
</span><span id="line-69"><span class="w">    </span><span class="n">vertexInterp2</span><span class="p">(</span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">field</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="n">vertlist</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span><span class="w"> </span><span class="n">normlist</span><span class="p">[</span><span class="mi">11</span><span class="p">]);</span>
</span><span id="line-70">
</span><span id="line-71"><span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">numVerts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tex1Dfeth</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numVertsTex</span><span class="p">,</span><span class="w"> </span><span class="n">cubeindex</span><span class="p">);</span>
</span><span id="line-72">
</span><span id="line-73"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVerts</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-74"><span class="w">        </span><span class="n">uint</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tex1Dfetch</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">triTex</span><span class="p">,</span><span class="w"> </span><span class="n">cubeindex</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
</span><span id="line-75"><span class="w">        </span><span class="n">uint</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numVertsScanned</span><span class="p">[</span><span class="n">voxel</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
</span><span id="line-76">
</span><span id="line-77"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maxVerts</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-78"><span class="w">            </span><span class="n">pos</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_float4</span><span class="p">(</span><span class="n">vertlist</span><span class="p">[</span><span class="n">edge</span><span class="p">],</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>
</span><span id="line-79"><span class="w">            </span><span class="n">norm</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_float4</span><span class="p">(</span><span class="n">normlist</span><span class="p">[</span><span class="n">edge</span><span class="p">],</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
</span><span id="line-80"><span class="w">        </span><span class="p">}</span>
</span><span id="line-81"><span class="w">    </span><span class="p">}</span>
</span><span id="line-82"><span class="p">}</span>
</span><span id="line-83">
</span><span id="line-84"><span class="k">extern</span><span class="w"> </span><span class="s">"C"</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">launch_generateTriangles</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="o">*</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="o">*</span><span class="n">norm</span><span class="p">,</span>
</span><span id="line-85"><span class="w">                                         </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">compactedVoxelArray</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">numVertsScanned</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSize</span><span class="p">,</span>
</span><span id="line-86"><span class="w">                                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">uint3</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">float3</span><span class="w"> </span><span class="n">voxelSize</span><span class="p">,</span>
</span><span id="line-87"><span class="w">                                         </span><span class="kt">float</span><span class="w"> </span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">activeVoxels</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">maxVerts</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-88">
</span><span id="line-89"><span class="w">    </span><span class="n">dpct</span><span class="o">::</span><span class="n">get_in_order_queue</span><span class="p">().</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cgh</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-90"><span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">triTex_acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">dpct</span><span class="o">::</span><span class="n">image_wrapper</span><span class="o">&lt;</span>
</span><span id="line-91"><span class="w">            </span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">triTex</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">get_access</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>
</span><span id="line-92"><span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">numVertsTex_acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">dpct</span><span class="o">::</span><span class="n">image_wrapper</span><span class="o">&lt;</span>
</span><span id="line-93"><span class="w">            </span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">numVertsTex</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">get_access</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>
</span><span id="line-94">
</span><span id="line-95"><span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">triTex_smpl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">triTex</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">get_sampler</span><span class="p">();</span>
</span><span id="line-96"><span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">numVertsTex_smpl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numVertsTex</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">get_sampler</span><span class="p">();</span>
</span><span id="line-97">
</span><span id="line-98"><span class="w">        </span><span class="n">cgh</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item_ct1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-99"><span class="w">            </span><span class="n">generateTriangles</span><span class="p">(</span>
</span><span id="line-100"><span class="w">                </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">norm</span><span class="p">,</span><span class="w"> </span><span class="n">compactedVoxelArray</span><span class="p">,</span><span class="w"> </span><span class="n">numVertsScanned</span><span class="p">,</span><span class="w"> </span><span class="n">gridSize</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeShift</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeMask</span><span class="p">,</span>
</span><span id="line-101"><span class="w">                </span><span class="n">voxelSize</span><span class="p">,</span><span class="w"> </span><span class="n">isoValue</span><span class="p">,</span><span class="w"> </span><span class="n">activeVoxels</span><span class="p">,</span><span class="w"> </span><span class="n">maxVerts</span><span class="p">,</span>
</span><span id="line-102"><span class="w">                </span><span class="n">dpct</span><span class="o">::</span><span class="n">image_accessor_ext</span><span class="o">&lt;</span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">triTex_smpl</span><span class="p">,</span><span class="w"> </span><span class="n">triTex_acc</span><span class="p">),</span>
</span><span id="line-103"><span class="w">                </span><span class="n">dpct</span><span class="o">::</span><span class="n">image_accessor_ext</span><span class="o">&lt;</span><span class="n">dpct_placeholder</span><span class="w"> </span><span class="cm">/* Fix this manually */</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span>
</span><span id="line-104"><span class="w">                    </span><span class="n">numVertsTex_smpl</span><span class="p">,</span><span class="w"> </span><span class="n">numVertsTex_acc</span><span class="p">),</span>
</span><span id="line-105"><span class="w">                </span><span class="n">item_ct1</span><span class="p">);</span>
</span><span id="line-106"><span class="w">        </span><span class="p">});</span>
</span><span id="line-107"><span class="w">    </span><span class="p">});</span>
</span><span id="line-108">
</span><span id="line-109"><span class="w">    </span><span class="n">getLastCudaError</span><span class="p">(</span><span class="s">"generateTriangles failed"</span><span class="p">);</span>
</span><span id="line-110"><span class="p">}</span>
</span></code></pre></div>
</div>
<p>In SYCL, the logi of the kernel remains the same, but the API calls and
syntax are changed to be compatible with the SYCL framework. The use of
<code class="docutils literal notranslate"><span class="pre">dpct::image_accessor_ext</span></code> for texture accesses and <code class="docutils literal notranslate"><span class="pre">sycl::nd_item</span></code>
for thread and block indices are notable chagnes. (MORE ON THIS SECTION
LATER)</p>
</section>
<section id="use-of-thrust-library-in-cuda-implementation">
<h3>Use of Thrust Library in CUDA Implementation:<a class="headerlink" href="#use-of-thrust-library-in-cuda-implementation" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#use-of-thrust-library-in-cuda-implementation'">Â¶</a></h3>
<p><strong>Understanding Prefix Sum Operations</strong></p>
<p>Beofre diving into how the Thrust library is used in the CUDA
implementation, it is essential to understand what prefix sum operations
are and why they are crucial in parallel algorithms.</p>
<p><strong>What is a Prefix Sum?</strong></p>
<p>A prefix sum, also known as a scan operation, is an operation that takes
an input array and produces an output array were each element at index
<code class="docutils literal notranslate"><span class="pre">i</span></code> is the sum of all the elements from the start of the input array
up to, but not including, the element at index <code class="docutils literal notranslate"><span class="pre">i</span></code>. In mathematical
terms, given an input array <code class="docutils literal notranslate"><span class="pre">A</span></code>, the prefix sum array <code class="docutils literal notranslate"><span class="pre">B</span></code> is defined
as:</p>
<div class="math notranslate nohighlight">
\[B[i] = \sum_{j=0}^{i} A[j]\]</div>
<p>For example, if the input array <code class="docutils literal notranslate"><span class="pre">A</span></code> is:</p>
<div class="math notranslate nohighlight">
\[A=[3,1,4,1,5,9,2,6,5]\]</div>
<p>then the prefix sum array <code class="docutils literal notranslate"><span class="pre">B</span></code> would be:</p>
<div class="math notranslate nohighlight">
\[B=[0,3,4,8,9,14,23,25,31]\]</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">B[0]</span></code> is 0 because there are no elements before the first
element of <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B[1]</span></code> is 3 which is just <code class="docutils literal notranslate"><span class="pre">A[0]</span></code>, <code class="docutils literal notranslate"><span class="pre">B[2]</span></code> is 4
which is <code class="docutils literal notranslate"><span class="pre">A[0]</span> <span class="pre">+</span> <span class="pre">A[1]</span></code>, and so on.</p>
<p>Prefix sums are a fundamental building block in parallel algorithms.
They are used in a variety of applications such as stream compaction,
sorting, and building data structures like histograms and cumulative
distributions. The prefix sum operation is inherently parallelizable
because each element in the output array can be computed independently
once the partial sums are known.</p>
<p>In our marching cubes algorithm, the prefix sum operation is used to
compact the voxel array. After classifying the voxels, we need to know
how many voxels are occupied up to each point in the array to
efficiently generate the triangles. This is where the prefix sum comes
into play.</p>
<p>After classifying each voxel as occupied or empty, we have an array
<code class="docutils literal notranslate"><span class="pre">voxelOccupied</span></code> where each element is a flag indicating whether a
voxel is occupied. We need to compact this array to remove the empty
voxels and create a contiguous array of occupied voxels. The prerfix sum
operation on the <code class="docutils literal notranslate"><span class="pre">voxelOccupied</span></code> array allows us to achieve this.</p>
<p>Using the prefix sum operation on the <code class="docutils literal notranslate"><span class="pre">voxelOccupied</span></code> array results in
the <code class="docutils literal notranslate"><span class="pre">voxelOccupiedScan</span></code> array. This array contains the running total
of occupied voxels up to each point. By using this array, we can
determine the position of each occupied voxel in the compacted array.</p>
<p><strong>Using Thrust in the CUDA Implementation</strong></p>
<p>Thrust is a parlalel algorithms library in CUDA that resembes the C++
Standard Template Library (STL). It provides a collection of data
parallel primitives such as scan, sort, and reduce. Thrust is highly
optimized for performance on NVIDIA GPUs by taking advanatge of CUDA
underneath the hood.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ThrustScanWrapper</span></code> function encapsulates the Thrust scan
operation - remember, scan is just another name for prefix sum. It uses
the <code class="docutils literal notranslate"><span class="pre">thrust::exclusize_scan</span></code> function to compute the prefix sum.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="k">extern</span><span class="w"> </span><span class="s">"C"</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ThrustScanWrapper</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numElements</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-2"><span class="w">    </span><span class="n">thrust</span><span class="o">::</span><span class="n">exclusive_scan</span><span class="p">(</span><span class="n">thrust</span><span class="o">::</span><span class="n">device_ptr</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">),</span>
</span><span id="line-3"><span class="w">                           </span><span class="n">thrust</span><span class="o">::</span><span class="n">device_ptr</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">numElements</span><span class="p">),</span>
</span><span id="line-4"><span class="w">                           </span><span class="n">thrust</span><span class="o">::</span><span class="n">device_ptr</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">output</span><span class="p">));</span>
</span><span id="line-5"><span class="p">}</span>
</span></code></pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">thrust::exclusize_scan</span></code> function takes three parameters: the
beginning of the input range, the end of the input range, and the
beginning of the output range. It computes the prefix sum of the input
range and stores the result in the output range. The exclusive scan
means that the sum at each position does not include the element at that
position, which aligns with the traditional definition of prefix sums.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">computeIsosurface</span></code> function, after classifying the voxels, a
scan operation is performed on the <code class="docutils literal notranslate"><span class="pre">voxelOccupied</span></code> array. Remember,
this array contains flags indicating whether each voxel is occupied. The
scan operation computes the prefix sum of this array, which results in
the <code class="docutils literal notranslate"><span class="pre">voxelOccupiedScan</span></code> array, which tells us how many occupied voxels
there are up to each position.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="n">ThrustScanWrapper</span><span class="p">(</span><span class="n">d_voxelOccupiedScan</span><span class="p">,</span><span class="w"> </span><span class="n">d_voxelOccupied</span><span class="p">,</span><span class="w"> </span><span class="n">numVoxels</span><span class="p">);</span>
</span></code></pre></div>
</div>
<p>Thre prefix sum operation is crucial for the compaction step. It allows
us to create a compact array of occupied voxels, eliminating the empty
ones. This compact array is then used in the <code class="docutils literal notranslate"><span class="pre">generateTriangles</span></code>
kernel to efficiently generate the triangles for the isosurface.</p>
</section>
<section id="use-onedpl-thrust-equivalent-in-sycl">
<h3>Use oneDPL (Thrust Equivalent) in SYCL:<a class="headerlink" href="#use-onedpl-thrust-equivalent-in-sycl" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#use-onedpl-thrust-equivalent-in-sycl'">Â¶</a></h3>
<p>oneDPL (oneAPI DPC++ Library) serves as the SYCL equivalent to CUDAâ€™s
Thrust library. Both libraries offer high-level abstractions for
parallel algorithms and data structures. In our marching cubes
algorithms, oneDPL can be used to perform the prefix sum (scan)
oeprations, which, we know from above, are crucial for stream compaction
and calculating the number of vertices.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">dpct::device_ext::exclusive_scan</span></code> function is used to perform the
prefix sum operation in SYCL. SYCLomatic helps convert Thrust-based code
to oneDPL-based code, although, just as with our kernels, some manual
adjustments may be required.</p>
<p>For example, the converted prefix sum operation using oneDPL might look
like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span id="line-1"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;oneapi/dpl/execution&gt;</span>
</span><span id="line-2"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;oneapi/dpl/algorithm&gt;</span>
</span><span id="line-3">
</span><span id="line-4"><span class="kt">void</span><span class="w"> </span><span class="nf">oneDPLScanWrapper</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numElements</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="line-5"><span class="w">    </span><span class="n">oneapi</span><span class="o">::</span><span class="n">dpl</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">make_device_policy</span><span class="p">(</span><span class="n">q</span><span class="p">),</span>
</span><span id="line-6"><span class="w">    </span><span class="n">oneapi</span><span class="o">::</span><span class="n">dpl</span><span class="o">::</span><span class="n">exclusive_scan</span><span class="p">(</span><span class="n">oneapi</span><span class="o">::</span><span class="n">dpl</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">make_device_policy</span><span class="p">(</span><span class="n">q</span><span class="p">),</span>
</span><span id="line-7"><span class="w">                                </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">numElements</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span>
</span><span id="line-8"><span class="p">}</span>
</span></code></pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">oneapi::dpl::exclusive_scan</span></code> performs the exclusive
prefix sum operation, similar to Thrust. The
<code class="docutils literal notranslate"><span class="pre">oneapi::dpl::execution::make_device_policy</span></code> function creates a device
policy for the queue, ensuring that the operation is execued on the
appropirate device.</p>
<p>(EDIT THIS SECTION AFTER IMPLEMENTATION)</p>
</section>
</section>
</section>
</div></div><aside class="hidden text-sm xl:block" id="right-sidebar">
<div class="sticky top-16 -mt-10 max-h-[calc(100vh-5rem)] overflow-y-auto pt-6 space-y-2"><p class="font-medium">On this page</p>
<ul>
<li><a :data-current="activeSection === '#a-brief-cuda-reivew'" class="reference internal" href="#a-brief-cuda-reivew">A Brief CUDA Reivew</a></li>
<li><a :data-current="activeSection === '#kernels-being-used'" class="reference internal" href="#kernels-being-used">Kernels Being Used</a></li>
<li><a :data-current="activeSection === '#cuda-vs-sycl-implementations'" class="reference internal" href="#cuda-vs-sycl-implementations">CUDA vs SYCL Implementations</a><ul>
<li><a :data-current="activeSection === '#classify-voxel-kernel-cuda'" class="reference internal" href="#classify-voxel-kernel-cuda">Classify Voxel Kernel - CUDA:</a></li>
<li><a :data-current="activeSection === '#classify-voxel-kernel-sycl'" class="reference internal" href="#classify-voxel-kernel-sycl">Classify Voxel Kernel - SYCL</a></li>
<li><a :data-current="activeSection === '#compact-voxels-kernel-cuda'" class="reference internal" href="#compact-voxels-kernel-cuda">Compact Voxels Kernel - CUDA</a></li>
<li><a :data-current="activeSection === '#compact-voxels-kernel-sycl'" class="reference internal" href="#compact-voxels-kernel-sycl">Compact Voxels Kernel - SYCL</a></li>
<li><a :data-current="activeSection === '#generate-triangles-kernel-cuda'" class="reference internal" href="#generate-triangles-kernel-cuda">Generate Triangles Kernel - CUDA:</a></li>
<li><a :data-current="activeSection === '#generate-triangles-kernel-sycl'" class="reference internal" href="#generate-triangles-kernel-sycl">Generate Triangles Kernel - SYCL:</a></li>
<li><a :data-current="activeSection === '#use-of-thrust-library-in-cuda-implementation'" class="reference internal" href="#use-of-thrust-library-in-cuda-implementation">Use of Thrust Library in CUDA Implementation:</a></li>
<li><a :data-current="activeSection === '#use-onedpl-thrust-equivalent-in-sycl'" class="reference internal" href="#use-onedpl-thrust-equivalent-in-sycl">Use oneDPL (Thrust Equivalent) in SYCL:</a></li>
</ul>
</li>
</ul>
</div>
</aside>
</main>
</div>
</div><footer class="py-6 border-t border-border md:py-0">
<div class="container flex flex-col items-center justify-between gap-4 md:h-24 md:flex-row">
<div class="flex flex-col items-center gap-4 px-8 md:flex-row md:gap-2 md:px-0">
<p class="text-sm leading-loose text-center text-muted-foreground md:text-left">Â© 2023-Present, George K. Thiruvathukal and Konstantin LÃ¤uferÂ Built with <a class="font-medium underline underline-offset-4" href="https://www.sphinx-doc.org" rel="noreferrer">Sphinx 8.2.3</a></p>
</div>
</div>
</footer>
</div>
<script src="../_static/documentation_options.js?v=ff44e7b3"></script>
<script src="../_static/doctools.js?v=9bcbadda"></script>
<script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
<script defer="defer" src="../_static/theme.js?v=073f68d9"></script>
<script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>